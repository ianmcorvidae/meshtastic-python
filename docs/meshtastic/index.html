<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>meshtastic API documentation</title>
<meta name="description" content="A library for the Meshtastic Client API …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>meshtastic</code></h1>
</header>
<section id="section-intro">
<h1 id="a-library-for-the-meshtastic-client-api">A library for the Meshtastic Client API</h1>
<p>Primary interfaces: SerialInterface, TCPInterface, BLEInterface
Install with pip: "<a href="https://pypi.org/project/meshtastic/">pip3 install meshtastic</a>"
Source code on <a href="https://github.com/meshtastic/python">github</a></p>
<p>notable properties of interface classes:</p>
<ul>
<li>nodes - The database of received nodes.
Includes always up-to-date location and username information for each
node in the mesh.
This is a read-only datastructure.</li>
<li>nodesByNum - like "nodes" but keyed by nodeNum instead of nodeId</li>
<li>myInfo &amp; metadata - Contain read-only information about the local radio device (software version, hardware version, etc)</li>
<li>localNode - Pointer to a node object for the local node</li>
</ul>
<p>notable properties of nodes:
- localConfig - Current radio settings, can be written to the radio with the <code>writeConfig</code> method.
- moduleConfig - Current module settings, can be written to the radio with the <code>writeConfig</code> method.
- channels - The node's channels, keyed by index.</p>
<h1 id="published-pubsub-topics">Published PubSub topics</h1>
<p>We use a <a href="https://pypubsub.readthedocs.io/en/v4.0.3/">publish-subscribe</a> model to communicate asynchronous events.
Available
topics:</p>
<ul>
<li>meshtastic.connection.established - published once we've successfully connected to the radio and downloaded the node DB</li>
<li>meshtastic.connection.lost - published once we've lost our link to the radio</li>
<li>meshtastic.receive.text(packet) - delivers a received packet as a dictionary, if you only care about a particular
type of packet, you should subscribe to the full topic name.
If you want to see all packets, simply subscribe to "meshtastic.receive".</li>
<li>meshtastic.receive.position(packet)</li>
<li>meshtastic.receive.user(packet)</li>
<li>meshtastic.receive.data.portnum(packet) (where portnum is an integer or well known PortNum enum)</li>
<li>meshtastic.node.updated(node = NodeInfo) - published when a node in the DB changes (appears, location changed, username changed, etc&hellip;)</li>
<li>meshtastic.log.line(line) - a raw unparsed log line from the radio</li>
</ul>
<p>We receive position, user, or data packets from the mesh.
You probably only care about meshtastic.receive.data.
The first argument for
that publish will be the packet.
Text or binary data packets (from sendData or sendText) will both arrive this way.
If you print packet
you'll see the fields in the dictionary.
decoded.data.payload will contain the raw bytes that were sent.
If the packet was sent with
sendText, decoded.data.text will <strong>also</strong> be populated with the decoded string.
For ASCII these two strings will be the same, but for
unicode scripts they can be different.</p>
<h1 id="example-usage">Example Usage</h1>
<pre><code>import meshtastic
import meshtastic.serial_interface
from pubsub import pub

def onReceive(packet, interface): # called when a packet arrives
    print(f&quot;Received: {packet}&quot;)

def onConnection(interface, topic=pub.AUTO_TOPIC): # called when we (re)connect to the radio
    # defaults to broadcast, specify a destination ID if you wish
    interface.sendText(&quot;hello mesh&quot;)

pub.subscribe(onReceive, &quot;meshtastic.receive&quot;)
pub.subscribe(onConnection, &quot;meshtastic.connection.established&quot;)
# By default will try to find a meshtastic device, otherwise provide a device path like /dev/ttyUSB0
interface = meshtastic.serial_interface.SerialInterface()

</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# A library for the Meshtastic Client API

Primary interfaces: SerialInterface, TCPInterface, BLEInterface
Install with pip: &#34;[pip3 install meshtastic](https://pypi.org/project/meshtastic/)&#34;
Source code on [github](https://github.com/meshtastic/python)

notable properties of interface classes:

- nodes - The database of received nodes.  Includes always up-to-date location and username information for each
node in the mesh.  This is a read-only datastructure.
- nodesByNum - like &#34;nodes&#34; but keyed by nodeNum instead of nodeId
- myInfo &amp; metadata - Contain read-only information about the local radio device (software version, hardware version, etc)
- localNode - Pointer to a node object for the local node

notable properties of nodes:
- localConfig - Current radio settings, can be written to the radio with the `writeConfig` method.
- moduleConfig - Current module settings, can be written to the radio with the `writeConfig` method.
- channels - The node&#39;s channels, keyed by index.

# Published PubSub topics

We use a [publish-subscribe](https://pypubsub.readthedocs.io/en/v4.0.3/) model to communicate asynchronous events.  Available
topics:

- meshtastic.connection.established - published once we&#39;ve successfully connected to the radio and downloaded the node DB
- meshtastic.connection.lost - published once we&#39;ve lost our link to the radio
- meshtastic.receive.text(packet) - delivers a received packet as a dictionary, if you only care about a particular
type of packet, you should subscribe to the full topic name.  If you want to see all packets, simply subscribe to &#34;meshtastic.receive&#34;.
- meshtastic.receive.position(packet)
- meshtastic.receive.user(packet)
- meshtastic.receive.data.portnum(packet) (where portnum is an integer or well known PortNum enum)
- meshtastic.node.updated(node = NodeInfo) - published when a node in the DB changes (appears, location changed, username changed, etc...)
- meshtastic.log.line(line) - a raw unparsed log line from the radio

We receive position, user, or data packets from the mesh.  You probably only care about meshtastic.receive.data.  The first argument for
that publish will be the packet.  Text or binary data packets (from sendData or sendText) will both arrive this way.  If you print packet
you&#39;ll see the fields in the dictionary.  decoded.data.payload will contain the raw bytes that were sent.  If the packet was sent with
sendText, decoded.data.text will **also** be populated with the decoded string.  For ASCII these two strings will be the same, but for
unicode scripts they can be different.

# Example Usage
```
import meshtastic
import meshtastic.serial_interface
from pubsub import pub

def onReceive(packet, interface): # called when a packet arrives
    print(f&#34;Received: {packet}&#34;)

def onConnection(interface, topic=pub.AUTO_TOPIC): # called when we (re)connect to the radio
    # defaults to broadcast, specify a destination ID if you wish
    interface.sendText(&#34;hello mesh&#34;)

pub.subscribe(onReceive, &#34;meshtastic.receive&#34;)
pub.subscribe(onConnection, &#34;meshtastic.connection.established&#34;)
# By default will try to find a meshtastic device, otherwise provide a device path like /dev/ttyUSB0
interface = meshtastic.serial_interface.SerialInterface()

```

&#34;&#34;&#34;

import base64
import logging
import os
import platform
import random
import socket
import stat
import sys
import threading
import time
import traceback
from datetime import datetime
from typing import *

import google.protobuf.json_format
import serial # type: ignore[import-untyped]
from dotmap import DotMap # type: ignore[import-untyped]
from google.protobuf.json_format import MessageToJson
from pubsub import pub # type: ignore[import-untyped]
from tabulate import tabulate

from meshtastic.node import Node
from meshtastic.util import DeferredExecution, Timeout, catchAndIgnore, fixme, stripnl

from .protobuf import (
    admin_pb2,
    apponly_pb2,
    channel_pb2,
    config_pb2,
    mesh_pb2,
    mqtt_pb2,
    paxcount_pb2,
    portnums_pb2,
    remote_hardware_pb2,
    storeforward_pb2,
    telemetry_pb2,
    powermon_pb2
)
from . import (
    util,
)

# Note: To follow PEP224, comments should be after the module variable.

LOCAL_ADDR = &#34;^local&#34;
&#34;&#34;&#34;A special ID that means the local node&#34;&#34;&#34;

BROADCAST_NUM = 0xFFFFFFFF
&#34;&#34;&#34;if using 8 bit nodenums this will be shortened on the target&#34;&#34;&#34;

BROADCAST_ADDR = &#34;^all&#34;
&#34;&#34;&#34;A special ID that means broadcast&#34;&#34;&#34;

OUR_APP_VERSION = 20300
&#34;&#34;&#34;The numeric buildnumber (shared with android apps) specifying the
   level of device code we are guaranteed to understand

   format is Mmmss (where M is 1+the numeric major number. i.e. 20120 means 1.1.20
&#34;&#34;&#34;

NODELESS_WANT_CONFIG_ID = 69420
&#34;&#34;&#34;A special thing to pass for want_config_id that instructs nodes to skip sending nodeinfos other than its own.&#34;&#34;&#34;

publishingThread = DeferredExecution(&#34;publishing&#34;)


class ResponseHandler(NamedTuple):
    &#34;&#34;&#34;A pending response callback, waiting for a response to one of our messages&#34;&#34;&#34;

    # requestId: int - used only as a key
    callback: Callable
    ackPermitted: bool = False
    # FIXME, add timestamp and age out old requests


class KnownProtocol(NamedTuple):
    &#34;&#34;&#34;Used to automatically decode known protocol payloads&#34;&#34;&#34;

    name: str
    # portnum: int, now a key
    # If set, will be called to prase as a protocol buffer
    protobufFactory: Optional[Callable] = None
    # If set, invoked as onReceive(interface, packet)
    onReceive: Optional[Callable] = None


def _onTextReceive(iface, asDict):
    &#34;&#34;&#34;Special text auto parsing for received messages&#34;&#34;&#34;
    # We don&#39;t throw if the utf8 is invalid in the text message.  Instead we just don&#39;t populate
    # the decoded.data.text and we log an error message.  This at least allows some delivery to
    # the app and the app can deal with the missing decoded representation.
    #
    # Usually btw this problem is caused by apps sending binary data but setting the payload type to
    # text.
    logging.debug(f&#34;in _onTextReceive() asDict:{asDict}&#34;)
    try:
        asBytes = asDict[&#34;decoded&#34;][&#34;payload&#34;]
        asDict[&#34;decoded&#34;][&#34;text&#34;] = asBytes.decode(&#34;utf-8&#34;)
    except Exception as ex:
        logging.error(f&#34;Malformatted utf8 in text message: {ex}&#34;)
    _receiveInfoUpdate(iface, asDict)


def _onPositionReceive(iface, asDict):
    &#34;&#34;&#34;Special auto parsing for received messages&#34;&#34;&#34;
    logging.debug(f&#34;in _onPositionReceive() asDict:{asDict}&#34;)
    if &#34;decoded&#34; in asDict:
        if &#34;position&#34; in asDict[&#34;decoded&#34;] and &#34;from&#34; in asDict:
            p = asDict[&#34;decoded&#34;][&#34;position&#34;]
            logging.debug(f&#34;p:{p}&#34;)
            p = iface._fixupPosition(p)
            logging.debug(f&#34;after fixup p:{p}&#34;)
            # update node DB as needed
            iface._getOrCreateByNum(asDict[&#34;from&#34;])[&#34;position&#34;] = p


def _onNodeInfoReceive(iface, asDict):
    &#34;&#34;&#34;Special auto parsing for received messages&#34;&#34;&#34;
    logging.debug(f&#34;in _onNodeInfoReceive() asDict:{asDict}&#34;)
    if &#34;decoded&#34; in asDict:
        if &#34;user&#34; in asDict[&#34;decoded&#34;] and &#34;from&#34; in asDict:
            p = asDict[&#34;decoded&#34;][&#34;user&#34;]
            # decode user protobufs and update nodedb, provide decoded version as &#34;position&#34; in the published msg
            # update node DB as needed
            n = iface._getOrCreateByNum(asDict[&#34;from&#34;])
            n[&#34;user&#34;] = p
            # We now have a node ID, make sure it is up-to-date in that table
            iface.nodes[p[&#34;id&#34;]] = n
            _receiveInfoUpdate(iface, asDict)

def _onTelemetryReceive(iface, asDict):
    &#34;&#34;&#34;Automatically update device metrics on received packets&#34;&#34;&#34;
    logging.debug(f&#34;in _onTelemetryReceive() asDict:{asDict}&#34;)
    deviceMetrics = asDict.get(&#34;decoded&#34;, {}).get(&#34;telemetry&#34;, {}).get(&#34;deviceMetrics&#34;)
    if &#34;from&#34; in asDict and deviceMetrics is not None:
        node = iface._getOrCreateByNum(asDict[&#34;from&#34;])
        newMetrics = node.get(&#34;deviceMetrics&#34;, {})
        newMetrics.update(deviceMetrics)
        logging.debug(f&#34;updating metrics for {asDict[&#39;from&#39;]} to {newMetrics}&#34;)
        node[&#34;deviceMetrics&#34;] = newMetrics

def _receiveInfoUpdate(iface, asDict):
    if &#34;from&#34; in asDict:
        iface._getOrCreateByNum(asDict[&#34;from&#34;])[&#34;lastReceived&#34;] = asDict
        iface._getOrCreateByNum(asDict[&#34;from&#34;])[&#34;lastHeard&#34;] = asDict.get(&#34;rxTime&#34;)
        iface._getOrCreateByNum(asDict[&#34;from&#34;])[&#34;snr&#34;] = asDict.get(&#34;rxSnr&#34;)
        iface._getOrCreateByNum(asDict[&#34;from&#34;])[&#34;hopLimit&#34;] = asDict.get(&#34;hopLimit&#34;)

def _onAdminReceive(iface, asDict):
    &#34;&#34;&#34;Special auto parsing for received messages&#34;&#34;&#34;
    logging.debug(f&#34;in _onAdminReceive() asDict:{asDict}&#34;)
    if &#34;decoded&#34; in asDict and &#34;from&#34; in asDict and &#34;admin&#34; in asDict[&#34;decoded&#34;]:
        adminMessage = asDict[&#34;decoded&#34;][&#34;admin&#34;][&#34;raw&#34;]
        iface._getOrCreateByNum(asDict[&#34;from&#34;])[&#34;adminSessionPassKey&#34;] = adminMessage.session_passkey

&#34;&#34;&#34;Well known message payloads can register decoders for automatic protobuf parsing&#34;&#34;&#34;
protocols = {
    portnums_pb2.PortNum.TEXT_MESSAGE_APP: KnownProtocol(
        &#34;text&#34;, onReceive=_onTextReceive
    ),
    portnums_pb2.PortNum.RANGE_TEST_APP: KnownProtocol(
        &#34;rangetest&#34;, onReceive=_onTextReceive
    ),
    portnums_pb2.PortNum.DETECTION_SENSOR_APP: KnownProtocol(
        &#34;detectionsensor&#34;, onReceive=_onTextReceive
    ),

    portnums_pb2.PortNum.POSITION_APP: KnownProtocol(
        &#34;position&#34;, mesh_pb2.Position, _onPositionReceive
    ),
    portnums_pb2.PortNum.NODEINFO_APP: KnownProtocol(
        &#34;user&#34;, mesh_pb2.User, _onNodeInfoReceive
    ),
    portnums_pb2.PortNum.ADMIN_APP: KnownProtocol(
        &#34;admin&#34;, admin_pb2.AdminMessage, _onAdminReceive
    ),
    portnums_pb2.PortNum.ROUTING_APP: KnownProtocol(&#34;routing&#34;, mesh_pb2.Routing),
    portnums_pb2.PortNum.TELEMETRY_APP: KnownProtocol(
        &#34;telemetry&#34;, telemetry_pb2.Telemetry, _onTelemetryReceive
    ),
    portnums_pb2.PortNum.REMOTE_HARDWARE_APP: KnownProtocol(
        &#34;remotehw&#34;, remote_hardware_pb2.HardwareMessage
    ),
    portnums_pb2.PortNum.SIMULATOR_APP: KnownProtocol(&#34;simulator&#34;, mesh_pb2.Compressed),
    portnums_pb2.PortNum.TRACEROUTE_APP: KnownProtocol(
        &#34;traceroute&#34;, mesh_pb2.RouteDiscovery
    ),
    portnums_pb2.PortNum.POWERSTRESS_APP: KnownProtocol(
        &#34;powerstress&#34;, powermon_pb2.PowerStressMessage
    ),
    portnums_pb2.PortNum.WAYPOINT_APP: KnownProtocol(&#34;waypoint&#34;, mesh_pb2.Waypoint),
    portnums_pb2.PortNum.PAXCOUNTER_APP: KnownProtocol(&#34;paxcounter&#34;, paxcount_pb2.Paxcount),
    portnums_pb2.PortNum.STORE_FORWARD_APP: KnownProtocol(&#34;storeforward&#34;, storeforward_pb2.StoreAndForward),
    portnums_pb2.PortNum.NEIGHBORINFO_APP: KnownProtocol(&#34;neighborinfo&#34;, mesh_pb2.NeighborInfo),
    portnums_pb2.PortNum.MAP_REPORT_APP: KnownProtocol(&#34;mapreport&#34;, mqtt_pb2.MapReport),
}</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="meshtastic.analysis" href="analysis/index.html">meshtastic.analysis</a></code></dt>
<dd>
<div class="desc"><p>Post-run analysis tools for meshtastic.</p></div>
</dd>
<dt><code class="name"><a title="meshtastic.ble_interface" href="ble_interface.html">meshtastic.ble_interface</a></code></dt>
<dd>
<div class="desc"><p>Bluetooth interface</p></div>
</dd>
<dt><code class="name"><a title="meshtastic.mesh_interface" href="mesh_interface.html">meshtastic.mesh_interface</a></code></dt>
<dd>
<div class="desc"><p>Mesh Interface class</p></div>
</dd>
<dt><code class="name"><a title="meshtastic.mt_config" href="mt_config.html">meshtastic.mt_config</a></code></dt>
<dd>
<div class="desc"><p>Globals singleton class …</p></div>
</dd>
<dt><code class="name"><a title="meshtastic.node" href="node.html">meshtastic.node</a></code></dt>
<dd>
<div class="desc"><p>Node class</p></div>
</dd>
<dt><code class="name"><a title="meshtastic.powermon" href="powermon/index.html">meshtastic.powermon</a></code></dt>
<dd>
<div class="desc"><p>Support for logging from power meters/supplies.</p></div>
</dd>
<dt><code class="name"><a title="meshtastic.protobuf" href="protobuf/index.html">meshtastic.protobuf</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="meshtastic.remote_hardware" href="remote_hardware.html">meshtastic.remote_hardware</a></code></dt>
<dd>
<div class="desc"><p>Remote hardware</p></div>
</dd>
<dt><code class="name"><a title="meshtastic.serial_interface" href="serial_interface.html">meshtastic.serial_interface</a></code></dt>
<dd>
<div class="desc"><p>Serial interface class</p></div>
</dd>
<dt><code class="name"><a title="meshtastic.slog" href="slog/index.html">meshtastic.slog</a></code></dt>
<dd>
<div class="desc"><p>Structured logging framework (see dev docs for more info).</p></div>
</dd>
<dt><code class="name"><a title="meshtastic.stream_interface" href="stream_interface.html">meshtastic.stream_interface</a></code></dt>
<dd>
<div class="desc"><p>Stream Interface base class</p></div>
</dd>
<dt><code class="name"><a title="meshtastic.supported_device" href="supported_device.html">meshtastic.supported_device</a></code></dt>
<dd>
<div class="desc"><p>Supported Meshtastic Devices - This is a class and collection of Meshtastic devices.
It is used for auto detection as to which device might be connected.</p></div>
</dd>
<dt><code class="name"><a title="meshtastic.tcp_interface" href="tcp_interface.html">meshtastic.tcp_interface</a></code></dt>
<dd>
<div class="desc"><p>TCPInterface class for interfacing with http endpoint</p></div>
</dd>
<dt><code class="name"><a title="meshtastic.test" href="test.html">meshtastic.test</a></code></dt>
<dd>
<div class="desc"><p>With two radios connected serially, send and receive test
messages and report back if successful.</p></div>
</dd>
<dt><code class="name"><a title="meshtastic.tests" href="tests/index.html">meshtastic.tests</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="meshtastic.tunnel" href="tunnel.html">meshtastic.tunnel</a></code></dt>
<dd>
<div class="desc"><p>Code for IP tunnel over a mesh …</p></div>
</dd>
<dt><code class="name"><a title="meshtastic.util" href="util.html">meshtastic.util</a></code></dt>
<dd>
<div class="desc"><p>Utility functions.</p></div>
</dd>
<dt><code class="name"><a title="meshtastic.version" href="version.html">meshtastic.version</a></code></dt>
<dd>
<div class="desc"><p>Version lookup utilities, isolated for cleanliness</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="meshtastic.BROADCAST_ADDR"><code class="name">var <span class="ident">BROADCAST_ADDR</span></code></dt>
<dd>
<div class="desc"><p>A special ID that means broadcast</p></div>
</dd>
<dt id="meshtastic.BROADCAST_NUM"><code class="name">var <span class="ident">BROADCAST_NUM</span></code></dt>
<dd>
<div class="desc"><p>if using 8 bit nodenums this will be shortened on the target</p></div>
</dd>
<dt id="meshtastic.LOCAL_ADDR"><code class="name">var <span class="ident">LOCAL_ADDR</span></code></dt>
<dd>
<div class="desc"><p>A special ID that means the local node</p></div>
</dd>
<dt id="meshtastic.NODELESS_WANT_CONFIG_ID"><code class="name">var <span class="ident">NODELESS_WANT_CONFIG_ID</span></code></dt>
<dd>
<div class="desc"><p>A special thing to pass for want_config_id that instructs nodes to skip sending nodeinfos other than its own.</p></div>
</dd>
<dt id="meshtastic.OUR_APP_VERSION"><code class="name">var <span class="ident">OUR_APP_VERSION</span></code></dt>
<dd>
<div class="desc"><p>The numeric buildnumber (shared with android apps) specifying the
level of device code we are guaranteed to understand</p>
<p>format is Mmmss (where M is 1+the numeric major number. i.e. 20120 means 1.1.20</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="meshtastic.KnownProtocol"><code class="flex name class">
<span>class <span class="ident">KnownProtocol</span></span>
<span>(</span><span>name: str, protobufFactory: Optional[Callable] = None, onReceive: Optional[Callable] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Used to automatically decode known protocol payloads</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KnownProtocol(NamedTuple):
    &#34;&#34;&#34;Used to automatically decode known protocol payloads&#34;&#34;&#34;

    name: str
    # portnum: int, now a key
    # If set, will be called to prase as a protocol buffer
    protobufFactory: Optional[Callable] = None
    # If set, invoked as onReceive(interface, packet)
    onReceive: Optional[Callable] = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="meshtastic.KnownProtocol.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="meshtastic.KnownProtocol.onReceive"><code class="name">var <span class="ident">onReceive</span> : Optional[Callable]</code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="meshtastic.KnownProtocol.protobufFactory"><code class="name">var <span class="ident">protobufFactory</span> : Optional[Callable]</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
</dl>
</dd>
<dt id="meshtastic.ResponseHandler"><code class="flex name class">
<span>class <span class="ident">ResponseHandler</span></span>
<span>(</span><span>callback: Callable, ackPermitted: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>A pending response callback, waiting for a response to one of our messages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResponseHandler(NamedTuple):
    &#34;&#34;&#34;A pending response callback, waiting for a response to one of our messages&#34;&#34;&#34;

    # requestId: int - used only as a key
    callback: Callable
    ackPermitted: bool = False
    # FIXME, add timestamp and age out old requests</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="meshtastic.ResponseHandler.ackPermitted"><code class="name">var <span class="ident">ackPermitted</span> : bool</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="meshtastic.ResponseHandler.callback"><code class="name">var <span class="ident">callback</span> : Callable</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#a-library-for-the-meshtastic-client-api">A library for the Meshtastic Client API</a></li>
<li><a href="#published-pubsub-topics">Published PubSub topics</a></li>
<li><a href="#example-usage">Example Usage</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="meshtastic.analysis" href="analysis/index.html">meshtastic.analysis</a></code></li>
<li><code><a title="meshtastic.ble_interface" href="ble_interface.html">meshtastic.ble_interface</a></code></li>
<li><code><a title="meshtastic.mesh_interface" href="mesh_interface.html">meshtastic.mesh_interface</a></code></li>
<li><code><a title="meshtastic.mt_config" href="mt_config.html">meshtastic.mt_config</a></code></li>
<li><code><a title="meshtastic.node" href="node.html">meshtastic.node</a></code></li>
<li><code><a title="meshtastic.powermon" href="powermon/index.html">meshtastic.powermon</a></code></li>
<li><code><a title="meshtastic.protobuf" href="protobuf/index.html">meshtastic.protobuf</a></code></li>
<li><code><a title="meshtastic.remote_hardware" href="remote_hardware.html">meshtastic.remote_hardware</a></code></li>
<li><code><a title="meshtastic.serial_interface" href="serial_interface.html">meshtastic.serial_interface</a></code></li>
<li><code><a title="meshtastic.slog" href="slog/index.html">meshtastic.slog</a></code></li>
<li><code><a title="meshtastic.stream_interface" href="stream_interface.html">meshtastic.stream_interface</a></code></li>
<li><code><a title="meshtastic.supported_device" href="supported_device.html">meshtastic.supported_device</a></code></li>
<li><code><a title="meshtastic.tcp_interface" href="tcp_interface.html">meshtastic.tcp_interface</a></code></li>
<li><code><a title="meshtastic.test" href="test.html">meshtastic.test</a></code></li>
<li><code><a title="meshtastic.tests" href="tests/index.html">meshtastic.tests</a></code></li>
<li><code><a title="meshtastic.tunnel" href="tunnel.html">meshtastic.tunnel</a></code></li>
<li><code><a title="meshtastic.util" href="util.html">meshtastic.util</a></code></li>
<li><code><a title="meshtastic.version" href="version.html">meshtastic.version</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="meshtastic.BROADCAST_ADDR" href="#meshtastic.BROADCAST_ADDR">BROADCAST_ADDR</a></code></li>
<li><code><a title="meshtastic.BROADCAST_NUM" href="#meshtastic.BROADCAST_NUM">BROADCAST_NUM</a></code></li>
<li><code><a title="meshtastic.LOCAL_ADDR" href="#meshtastic.LOCAL_ADDR">LOCAL_ADDR</a></code></li>
<li><code><a title="meshtastic.NODELESS_WANT_CONFIG_ID" href="#meshtastic.NODELESS_WANT_CONFIG_ID">NODELESS_WANT_CONFIG_ID</a></code></li>
<li><code><a title="meshtastic.OUR_APP_VERSION" href="#meshtastic.OUR_APP_VERSION">OUR_APP_VERSION</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="meshtastic.KnownProtocol" href="#meshtastic.KnownProtocol">KnownProtocol</a></code></h4>
<ul class="">
<li><code><a title="meshtastic.KnownProtocol.name" href="#meshtastic.KnownProtocol.name">name</a></code></li>
<li><code><a title="meshtastic.KnownProtocol.onReceive" href="#meshtastic.KnownProtocol.onReceive">onReceive</a></code></li>
<li><code><a title="meshtastic.KnownProtocol.protobufFactory" href="#meshtastic.KnownProtocol.protobufFactory">protobufFactory</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="meshtastic.ResponseHandler" href="#meshtastic.ResponseHandler">ResponseHandler</a></code></h4>
<ul class="">
<li><code><a title="meshtastic.ResponseHandler.ackPermitted" href="#meshtastic.ResponseHandler.ackPermitted">ackPermitted</a></code></li>
<li><code><a title="meshtastic.ResponseHandler.callback" href="#meshtastic.ResponseHandler.callback">callback</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>