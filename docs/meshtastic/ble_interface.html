<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>meshtastic.ble_interface API documentation</title>
<meta name="description" content="Bluetooth interface" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>meshtastic.ble_interface</code></h1>
</header>
<section id="section-intro">
<p>Bluetooth interface</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Bluetooth interface
&#34;&#34;&#34;
import asyncio
import atexit
import logging
import struct
import time
from threading import Thread
from typing import List, Optional

import google.protobuf
from bleak import BleakClient, BleakScanner, BLEDevice
from bleak.exc import BleakDBusError, BleakError

from meshtastic.mesh_interface import MeshInterface

from .protobuf import mesh_pb2

SERVICE_UUID = &#34;6ba1b218-15a8-461f-9fa8-5dcae273eafd&#34;
TORADIO_UUID = &#34;f75c76d2-129e-4dad-a1dd-7866124401e7&#34;
FROMRADIO_UUID = &#34;2c55e69e-4993-11ed-b878-0242ac120002&#34;
FROMNUM_UUID = &#34;ed9da18c-a800-4f66-a670-aa7547e34453&#34;
LEGACY_LOGRADIO_UUID = &#34;6c6fd238-78fa-436b-aacf-15c5be1ef2e2&#34;
LOGRADIO_UUID = &#34;5a3d6e49-06e6-4423-9944-e9de8cdf9547&#34;


class BLEInterface(MeshInterface):
    &#34;&#34;&#34;MeshInterface using BLE to connect to devices.&#34;&#34;&#34;

    class BLEError(Exception):
        &#34;&#34;&#34;An exception class for BLE errors.&#34;&#34;&#34;

    def __init__(
        self,
        address: Optional[str],
        noProto: bool = False,
        debugOut=None,
        noNodes: bool = False,
    ):
        MeshInterface.__init__(
            self, debugOut=debugOut, noProto=noProto, noNodes=noNodes
        )

        self.should_read = False

        logging.debug(&#34;Threads starting&#34;)
        self._want_receive = True
        self._receiveThread: Optional[Thread] = Thread(
            target=self._receiveFromRadioImpl, name=&#34;BLEReceive&#34;, daemon=True
        )
        self._receiveThread.start()
        logging.debug(&#34;Threads running&#34;)

        self.client: Optional[BLEClient] = None
        try:
            logging.debug(f&#34;BLE connecting to: {address if address else &#39;any&#39;}&#34;)
            self.client = self.connect(address)
            logging.debug(&#34;BLE connected&#34;)
        except BLEInterface.BLEError as e:
            self.close()
            raise e

        if self.client.has_characteristic(LEGACY_LOGRADIO_UUID):
            self.client.start_notify(
                LEGACY_LOGRADIO_UUID, self.legacy_log_radio_handler
            )

        if self.client.has_characteristic(LOGRADIO_UUID):
            self.client.start_notify(LOGRADIO_UUID, self.log_radio_handler)

        logging.debug(&#34;Mesh configure starting&#34;)
        self._startConfig()
        if not self.noProto:
            self._waitConnected(timeout=60.0)
            self.waitForConfig()

        logging.debug(&#34;Register FROMNUM notify callback&#34;)
        self.client.start_notify(FROMNUM_UUID, self.from_num_handler)

        # We MUST run atexit (if we can) because otherwise (at least on linux) the BLE device is not disconnected
        # and future connection attempts will fail.  (BlueZ kinda sucks)
        # Note: the on disconnected callback will call our self.close which will make us nicely wait for threads to exit
        self._exit_handler = atexit.register(self.client.disconnect)

    def from_num_handler(self, _, b):  # pylint: disable=C0116
        &#34;&#34;&#34;Handle callbacks for fromnum notify.
        Note: this method does not need to be async because it is just setting a bool.
        &#34;&#34;&#34;
        from_num = struct.unpack(&#34;&lt;I&#34;, bytes(b))[0]
        logging.debug(f&#34;FROMNUM notify: {from_num}&#34;)
        self.should_read = True

    async def log_radio_handler(self, _, b):  # pylint: disable=C0116
        log_record = mesh_pb2.LogRecord()
        try:
            log_record.ParseFromString(bytes(b))

            message = (
                f&#34;[{log_record.source}] {log_record.message}&#34;
                if log_record.source
                else log_record.message
            )
            self._handleLogLine(message)
        except google.protobuf.message.DecodeError:
            logging.warning(&#34;Malformed LogRecord received. Skipping.&#34;)

    async def legacy_log_radio_handler(self, _, b):  # pylint: disable=C0116
        log_radio = b.decode(&#34;utf-8&#34;).replace(&#34;\n&#34;, &#34;&#34;)
        self._handleLogLine(log_radio)

    @staticmethod
    def scan() -&gt; List[BLEDevice]:
        &#34;&#34;&#34;Scan for available BLE devices.&#34;&#34;&#34;
        with BLEClient() as client:
            logging.info(&#34;Scanning for BLE devices (takes 10 seconds)...&#34;)
            response = client.discover(
                timeout=10, return_adv=True, service_uuids=[SERVICE_UUID]
            )

            devices = response.values()

            # bleak sometimes returns devices we didn&#39;t ask for, so filter the response
            # to only return true meshtastic devices
            # d[0] is the device. d[1] is the advertisement data
            devices = list(
                filter(lambda d: SERVICE_UUID in d[1].service_uuids, devices)
            )
            return list(map(lambda d: d[0], devices))

    def find_device(self, address: Optional[str]) -&gt; BLEDevice:
        &#34;&#34;&#34;Find a device by address.&#34;&#34;&#34;

        addressed_devices = BLEInterface.scan()

        if address:
            addressed_devices = list(
                filter(
                    lambda x: address in (x.name, x.address),
                    addressed_devices,
                )
            )

        if len(addressed_devices) == 0:
            raise BLEInterface.BLEError(
                f&#34;No Meshtastic BLE peripheral with identifier or address &#39;{address}&#39; found. Try --ble-scan to find it.&#34;
            )
        if len(addressed_devices) &gt; 1:
            raise BLEInterface.BLEError(
                f&#34;More than one Meshtastic BLE peripheral with identifier or address &#39;{address}&#39; found.&#34;
            )
        return addressed_devices[0]

    def _sanitize_address(address):  # pylint: disable=E0213
        &#34;Standardize BLE address by removing extraneous characters and lowercasing.&#34;
        return address.replace(&#34;-&#34;, &#34;&#34;).replace(&#34;_&#34;, &#34;&#34;).replace(&#34;:&#34;, &#34;&#34;).lower()

    def connect(self, address: Optional[str] = None) -&gt; &#34;BLEClient&#34;:
        &#34;Connect to a device by address.&#34;

        # Bleak docs recommend always doing a scan before connecting (even if we know addr)
        device = self.find_device(address)
        client = BLEClient(device.address, disconnected_callback=lambda _: self.close)
        client.connect()
        client.discover()
        return client

    def _receiveFromRadioImpl(self):
        while self._want_receive:
            if self.should_read:
                self.should_read = False
                retries = 0
                while self._want_receive:
                    try:
                        b = bytes(self.client.read_gatt_char(FROMRADIO_UUID))
                    except BleakDBusError as e:
                        # Device disconnected probably, so end our read loop immediately
                        logging.debug(f&#34;Device disconnected, shutting down {e}&#34;)
                        self._want_receive = False
                    except BleakError as e:
                        # We were definitely disconnected
                        if &#34;Not connected&#34; in str(e):
                            logging.debug(f&#34;Device disconnected, shutting down {e}&#34;)
                            self._want_receive = False
                        else:
                            raise BLEInterface.BLEError(&#34;Error reading BLE&#34;) from e
                    if not b:
                        if retries &lt; 5:
                            time.sleep(0.1)
                            retries += 1
                            continue
                        break
                    logging.debug(f&#34;FROMRADIO read: {b.hex()}&#34;)
                    self._handleFromRadio(b)
            else:
                time.sleep(0.01)

    def _sendToRadioImpl(self, toRadio):
        b = toRadio.SerializeToString()
        if b and self.client:  # we silently ignore writes while we are shutting down
            logging.debug(f&#34;TORADIO write: {b.hex()}&#34;)
            try:
                self.client.write_gatt_char(
                    TORADIO_UUID, b, response=True
                )  # FIXME: or False?
                # search Bleak src for org.bluez.Error.InProgress
            except Exception as e:
                raise BLEInterface.BLEError(
                    &#34;Error writing BLE (are you in the &#39;bluetooth&#39; user group? did you enter the pairing PIN on your computer?)&#34;
                ) from e
            # Allow to propagate and then make sure we read
            time.sleep(0.01)
            self.should_read = True

    def close(self):
        try:
            MeshInterface.close(self)
        except Exception as e:
            logging.error(f&#34;Error closing mesh interface: {e}&#34;)

        if self._want_receive:
            self.want_receive = False  # Tell the thread we want it to stop
            if self._receiveThread:
                self._receiveThread.join(
                    timeout=2
                )  # If bleak is hung, don&#39;t wait for the thread to exit (it is critical we disconnect)
                self._receiveThread = None

        if self.client:
            atexit.unregister(self._exit_handler)
            self.client.disconnect()
            self.client.close()
            self.client = None


class BLEClient:
    &#34;&#34;&#34;Client for managing connection to a BLE device&#34;&#34;&#34;

    def __init__(self, address=None, **kwargs):
        self._eventLoop = asyncio.new_event_loop()
        self._eventThread = Thread(
            target=self._run_event_loop, name=&#34;BLEClient&#34;, daemon=True
        )
        self._eventThread.start()

        if not address:
            logging.debug(&#34;No address provided - only discover method will work.&#34;)
            return

        self.bleak_client = BleakClient(address, **kwargs)

    def discover(self, **kwargs):  # pylint: disable=C0116
        return self.async_await(BleakScanner.discover(**kwargs))

    def pair(self, **kwargs):  # pylint: disable=C0116
        return self.async_await(self.bleak_client.pair(**kwargs))

    def connect(self, **kwargs):  # pylint: disable=C0116
        return self.async_await(self.bleak_client.connect(**kwargs))

    def disconnect(self, **kwargs):  # pylint: disable=C0116
        self.async_await(self.bleak_client.disconnect(**kwargs))

    def read_gatt_char(self, *args, **kwargs):  # pylint: disable=C0116
        return self.async_await(self.bleak_client.read_gatt_char(*args, **kwargs))

    def write_gatt_char(self, *args, **kwargs):  # pylint: disable=C0116
        self.async_await(self.bleak_client.write_gatt_char(*args, **kwargs))

    def has_characteristic(self, specifier):
        &#34;&#34;&#34;Check if the connected node supports a specified characteristic.&#34;&#34;&#34;
        return bool(self.bleak_client.services.get_characteristic(specifier))

    def start_notify(self, *args, **kwargs):  # pylint: disable=C0116
        self.async_await(self.bleak_client.start_notify(*args, **kwargs))

    def close(self):  # pylint: disable=C0116
        self.async_run(self._stop_event_loop())
        self._eventThread.join()

    def __enter__(self):
        return self

    def __exit__(self, _type, _value, _traceback):
        self.close()

    def async_await(self, coro, timeout=None):  # pylint: disable=C0116
        return self.async_run(coro).result(timeout)

    def async_run(self, coro):  # pylint: disable=C0116
        return asyncio.run_coroutine_threadsafe(coro, self._eventLoop)

    def _run_event_loop(self):
        try:
            self._eventLoop.run_forever()
        finally:
            self._eventLoop.close()

    async def _stop_event_loop(self):
        self._eventLoop.stop()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="meshtastic.ble_interface.BLEClient"><code class="flex name class">
<span>class <span class="ident">BLEClient</span></span>
<span>(</span><span>address=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Client for managing connection to a BLE device</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BLEClient:
    &#34;&#34;&#34;Client for managing connection to a BLE device&#34;&#34;&#34;

    def __init__(self, address=None, **kwargs):
        self._eventLoop = asyncio.new_event_loop()
        self._eventThread = Thread(
            target=self._run_event_loop, name=&#34;BLEClient&#34;, daemon=True
        )
        self._eventThread.start()

        if not address:
            logging.debug(&#34;No address provided - only discover method will work.&#34;)
            return

        self.bleak_client = BleakClient(address, **kwargs)

    def discover(self, **kwargs):  # pylint: disable=C0116
        return self.async_await(BleakScanner.discover(**kwargs))

    def pair(self, **kwargs):  # pylint: disable=C0116
        return self.async_await(self.bleak_client.pair(**kwargs))

    def connect(self, **kwargs):  # pylint: disable=C0116
        return self.async_await(self.bleak_client.connect(**kwargs))

    def disconnect(self, **kwargs):  # pylint: disable=C0116
        self.async_await(self.bleak_client.disconnect(**kwargs))

    def read_gatt_char(self, *args, **kwargs):  # pylint: disable=C0116
        return self.async_await(self.bleak_client.read_gatt_char(*args, **kwargs))

    def write_gatt_char(self, *args, **kwargs):  # pylint: disable=C0116
        self.async_await(self.bleak_client.write_gatt_char(*args, **kwargs))

    def has_characteristic(self, specifier):
        &#34;&#34;&#34;Check if the connected node supports a specified characteristic.&#34;&#34;&#34;
        return bool(self.bleak_client.services.get_characteristic(specifier))

    def start_notify(self, *args, **kwargs):  # pylint: disable=C0116
        self.async_await(self.bleak_client.start_notify(*args, **kwargs))

    def close(self):  # pylint: disable=C0116
        self.async_run(self._stop_event_loop())
        self._eventThread.join()

    def __enter__(self):
        return self

    def __exit__(self, _type, _value, _traceback):
        self.close()

    def async_await(self, coro, timeout=None):  # pylint: disable=C0116
        return self.async_run(coro).result(timeout)

    def async_run(self, coro):  # pylint: disable=C0116
        return asyncio.run_coroutine_threadsafe(coro, self._eventLoop)

    def _run_event_loop(self):
        try:
            self._eventLoop.run_forever()
        finally:
            self._eventLoop.close()

    async def _stop_event_loop(self):
        self._eventLoop.stop()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="meshtastic.ble_interface.BLEClient.async_await"><code class="name flex">
<span>def <span class="ident">async_await</span></span>(<span>self, coro, timeout=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def async_await(self, coro, timeout=None):  # pylint: disable=C0116
    return self.async_run(coro).result(timeout)</code></pre>
</details>
</dd>
<dt id="meshtastic.ble_interface.BLEClient.async_run"><code class="name flex">
<span>def <span class="ident">async_run</span></span>(<span>self, coro)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def async_run(self, coro):  # pylint: disable=C0116
    return asyncio.run_coroutine_threadsafe(coro, self._eventLoop)</code></pre>
</details>
</dd>
<dt id="meshtastic.ble_interface.BLEClient.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):  # pylint: disable=C0116
    self.async_run(self._stop_event_loop())
    self._eventThread.join()</code></pre>
</details>
</dd>
<dt id="meshtastic.ble_interface.BLEClient.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self, **kwargs):  # pylint: disable=C0116
    return self.async_await(self.bleak_client.connect(**kwargs))</code></pre>
</details>
</dd>
<dt id="meshtastic.ble_interface.BLEClient.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self, **kwargs):  # pylint: disable=C0116
    self.async_await(self.bleak_client.disconnect(**kwargs))</code></pre>
</details>
</dd>
<dt id="meshtastic.ble_interface.BLEClient.discover"><code class="name flex">
<span>def <span class="ident">discover</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def discover(self, **kwargs):  # pylint: disable=C0116
    return self.async_await(BleakScanner.discover(**kwargs))</code></pre>
</details>
</dd>
<dt id="meshtastic.ble_interface.BLEClient.has_characteristic"><code class="name flex">
<span>def <span class="ident">has_characteristic</span></span>(<span>self, specifier)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the connected node supports a specified characteristic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_characteristic(self, specifier):
    &#34;&#34;&#34;Check if the connected node supports a specified characteristic.&#34;&#34;&#34;
    return bool(self.bleak_client.services.get_characteristic(specifier))</code></pre>
</details>
</dd>
<dt id="meshtastic.ble_interface.BLEClient.pair"><code class="name flex">
<span>def <span class="ident">pair</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pair(self, **kwargs):  # pylint: disable=C0116
    return self.async_await(self.bleak_client.pair(**kwargs))</code></pre>
</details>
</dd>
<dt id="meshtastic.ble_interface.BLEClient.read_gatt_char"><code class="name flex">
<span>def <span class="ident">read_gatt_char</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_gatt_char(self, *args, **kwargs):  # pylint: disable=C0116
    return self.async_await(self.bleak_client.read_gatt_char(*args, **kwargs))</code></pre>
</details>
</dd>
<dt id="meshtastic.ble_interface.BLEClient.start_notify"><code class="name flex">
<span>def <span class="ident">start_notify</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_notify(self, *args, **kwargs):  # pylint: disable=C0116
    self.async_await(self.bleak_client.start_notify(*args, **kwargs))</code></pre>
</details>
</dd>
<dt id="meshtastic.ble_interface.BLEClient.write_gatt_char"><code class="name flex">
<span>def <span class="ident">write_gatt_char</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_gatt_char(self, *args, **kwargs):  # pylint: disable=C0116
    self.async_await(self.bleak_client.write_gatt_char(*args, **kwargs))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="meshtastic.ble_interface.BLEInterface"><code class="flex name class">
<span>class <span class="ident">BLEInterface</span></span>
<span>(</span><span>address: Optional[str], noProto: bool = False, debugOut=None, noNodes: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>MeshInterface using BLE to connect to devices.</p>
<p>Constructor</p>
<p>Keyword Arguments:
noProto &ndash; If True, don't try to run our protocol on the
link - just be a dumb serial client.
noNodes &ndash; If True, instruct the node to not send its nodedb
on startup, just other configuration information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BLEInterface(MeshInterface):
    &#34;&#34;&#34;MeshInterface using BLE to connect to devices.&#34;&#34;&#34;

    class BLEError(Exception):
        &#34;&#34;&#34;An exception class for BLE errors.&#34;&#34;&#34;

    def __init__(
        self,
        address: Optional[str],
        noProto: bool = False,
        debugOut=None,
        noNodes: bool = False,
    ):
        MeshInterface.__init__(
            self, debugOut=debugOut, noProto=noProto, noNodes=noNodes
        )

        self.should_read = False

        logging.debug(&#34;Threads starting&#34;)
        self._want_receive = True
        self._receiveThread: Optional[Thread] = Thread(
            target=self._receiveFromRadioImpl, name=&#34;BLEReceive&#34;, daemon=True
        )
        self._receiveThread.start()
        logging.debug(&#34;Threads running&#34;)

        self.client: Optional[BLEClient] = None
        try:
            logging.debug(f&#34;BLE connecting to: {address if address else &#39;any&#39;}&#34;)
            self.client = self.connect(address)
            logging.debug(&#34;BLE connected&#34;)
        except BLEInterface.BLEError as e:
            self.close()
            raise e

        if self.client.has_characteristic(LEGACY_LOGRADIO_UUID):
            self.client.start_notify(
                LEGACY_LOGRADIO_UUID, self.legacy_log_radio_handler
            )

        if self.client.has_characteristic(LOGRADIO_UUID):
            self.client.start_notify(LOGRADIO_UUID, self.log_radio_handler)

        logging.debug(&#34;Mesh configure starting&#34;)
        self._startConfig()
        if not self.noProto:
            self._waitConnected(timeout=60.0)
            self.waitForConfig()

        logging.debug(&#34;Register FROMNUM notify callback&#34;)
        self.client.start_notify(FROMNUM_UUID, self.from_num_handler)

        # We MUST run atexit (if we can) because otherwise (at least on linux) the BLE device is not disconnected
        # and future connection attempts will fail.  (BlueZ kinda sucks)
        # Note: the on disconnected callback will call our self.close which will make us nicely wait for threads to exit
        self._exit_handler = atexit.register(self.client.disconnect)

    def from_num_handler(self, _, b):  # pylint: disable=C0116
        &#34;&#34;&#34;Handle callbacks for fromnum notify.
        Note: this method does not need to be async because it is just setting a bool.
        &#34;&#34;&#34;
        from_num = struct.unpack(&#34;&lt;I&#34;, bytes(b))[0]
        logging.debug(f&#34;FROMNUM notify: {from_num}&#34;)
        self.should_read = True

    async def log_radio_handler(self, _, b):  # pylint: disable=C0116
        log_record = mesh_pb2.LogRecord()
        try:
            log_record.ParseFromString(bytes(b))

            message = (
                f&#34;[{log_record.source}] {log_record.message}&#34;
                if log_record.source
                else log_record.message
            )
            self._handleLogLine(message)
        except google.protobuf.message.DecodeError:
            logging.warning(&#34;Malformed LogRecord received. Skipping.&#34;)

    async def legacy_log_radio_handler(self, _, b):  # pylint: disable=C0116
        log_radio = b.decode(&#34;utf-8&#34;).replace(&#34;\n&#34;, &#34;&#34;)
        self._handleLogLine(log_radio)

    @staticmethod
    def scan() -&gt; List[BLEDevice]:
        &#34;&#34;&#34;Scan for available BLE devices.&#34;&#34;&#34;
        with BLEClient() as client:
            logging.info(&#34;Scanning for BLE devices (takes 10 seconds)...&#34;)
            response = client.discover(
                timeout=10, return_adv=True, service_uuids=[SERVICE_UUID]
            )

            devices = response.values()

            # bleak sometimes returns devices we didn&#39;t ask for, so filter the response
            # to only return true meshtastic devices
            # d[0] is the device. d[1] is the advertisement data
            devices = list(
                filter(lambda d: SERVICE_UUID in d[1].service_uuids, devices)
            )
            return list(map(lambda d: d[0], devices))

    def find_device(self, address: Optional[str]) -&gt; BLEDevice:
        &#34;&#34;&#34;Find a device by address.&#34;&#34;&#34;

        addressed_devices = BLEInterface.scan()

        if address:
            addressed_devices = list(
                filter(
                    lambda x: address in (x.name, x.address),
                    addressed_devices,
                )
            )

        if len(addressed_devices) == 0:
            raise BLEInterface.BLEError(
                f&#34;No Meshtastic BLE peripheral with identifier or address &#39;{address}&#39; found. Try --ble-scan to find it.&#34;
            )
        if len(addressed_devices) &gt; 1:
            raise BLEInterface.BLEError(
                f&#34;More than one Meshtastic BLE peripheral with identifier or address &#39;{address}&#39; found.&#34;
            )
        return addressed_devices[0]

    def _sanitize_address(address):  # pylint: disable=E0213
        &#34;Standardize BLE address by removing extraneous characters and lowercasing.&#34;
        return address.replace(&#34;-&#34;, &#34;&#34;).replace(&#34;_&#34;, &#34;&#34;).replace(&#34;:&#34;, &#34;&#34;).lower()

    def connect(self, address: Optional[str] = None) -&gt; &#34;BLEClient&#34;:
        &#34;Connect to a device by address.&#34;

        # Bleak docs recommend always doing a scan before connecting (even if we know addr)
        device = self.find_device(address)
        client = BLEClient(device.address, disconnected_callback=lambda _: self.close)
        client.connect()
        client.discover()
        return client

    def _receiveFromRadioImpl(self):
        while self._want_receive:
            if self.should_read:
                self.should_read = False
                retries = 0
                while self._want_receive:
                    try:
                        b = bytes(self.client.read_gatt_char(FROMRADIO_UUID))
                    except BleakDBusError as e:
                        # Device disconnected probably, so end our read loop immediately
                        logging.debug(f&#34;Device disconnected, shutting down {e}&#34;)
                        self._want_receive = False
                    except BleakError as e:
                        # We were definitely disconnected
                        if &#34;Not connected&#34; in str(e):
                            logging.debug(f&#34;Device disconnected, shutting down {e}&#34;)
                            self._want_receive = False
                        else:
                            raise BLEInterface.BLEError(&#34;Error reading BLE&#34;) from e
                    if not b:
                        if retries &lt; 5:
                            time.sleep(0.1)
                            retries += 1
                            continue
                        break
                    logging.debug(f&#34;FROMRADIO read: {b.hex()}&#34;)
                    self._handleFromRadio(b)
            else:
                time.sleep(0.01)

    def _sendToRadioImpl(self, toRadio):
        b = toRadio.SerializeToString()
        if b and self.client:  # we silently ignore writes while we are shutting down
            logging.debug(f&#34;TORADIO write: {b.hex()}&#34;)
            try:
                self.client.write_gatt_char(
                    TORADIO_UUID, b, response=True
                )  # FIXME: or False?
                # search Bleak src for org.bluez.Error.InProgress
            except Exception as e:
                raise BLEInterface.BLEError(
                    &#34;Error writing BLE (are you in the &#39;bluetooth&#39; user group? did you enter the pairing PIN on your computer?)&#34;
                ) from e
            # Allow to propagate and then make sure we read
            time.sleep(0.01)
            self.should_read = True

    def close(self):
        try:
            MeshInterface.close(self)
        except Exception as e:
            logging.error(f&#34;Error closing mesh interface: {e}&#34;)

        if self._want_receive:
            self.want_receive = False  # Tell the thread we want it to stop
            if self._receiveThread:
                self._receiveThread.join(
                    timeout=2
                )  # If bleak is hung, don&#39;t wait for the thread to exit (it is critical we disconnect)
                self._receiveThread = None

        if self.client:
            atexit.unregister(self._exit_handler)
            self.client.disconnect()
            self.client.close()
            self.client = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="meshtastic.mesh_interface.MeshInterface" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface">MeshInterface</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="meshtastic.ble_interface.BLEInterface.BLEError"><code class="name">var <span class="ident">BLEError</span></code></dt>
<dd>
<div class="desc"><p>An exception class for BLE errors.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="meshtastic.ble_interface.BLEInterface.scan"><code class="name flex">
<span>def <span class="ident">scan</span></span>(<span>) ‑> List[bleak.backends.device.BLEDevice]</span>
</code></dt>
<dd>
<div class="desc"><p>Scan for available BLE devices.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def scan() -&gt; List[BLEDevice]:
    &#34;&#34;&#34;Scan for available BLE devices.&#34;&#34;&#34;
    with BLEClient() as client:
        logging.info(&#34;Scanning for BLE devices (takes 10 seconds)...&#34;)
        response = client.discover(
            timeout=10, return_adv=True, service_uuids=[SERVICE_UUID]
        )

        devices = response.values()

        # bleak sometimes returns devices we didn&#39;t ask for, so filter the response
        # to only return true meshtastic devices
        # d[0] is the device. d[1] is the advertisement data
        devices = list(
            filter(lambda d: SERVICE_UUID in d[1].service_uuids, devices)
        )
        return list(map(lambda d: d[0], devices))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="meshtastic.ble_interface.BLEInterface.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self, address: Optional[str] = None) ‑> <a title="meshtastic.ble_interface.BLEClient" href="#meshtastic.ble_interface.BLEClient">BLEClient</a></span>
</code></dt>
<dd>
<div class="desc"><p>Connect to a device by address.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self, address: Optional[str] = None) -&gt; &#34;BLEClient&#34;:
    &#34;Connect to a device by address.&#34;

    # Bleak docs recommend always doing a scan before connecting (even if we know addr)
    device = self.find_device(address)
    client = BLEClient(device.address, disconnected_callback=lambda _: self.close)
    client.connect()
    client.discover()
    return client</code></pre>
</details>
</dd>
<dt id="meshtastic.ble_interface.BLEInterface.find_device"><code class="name flex">
<span>def <span class="ident">find_device</span></span>(<span>self, address: Optional[str]) ‑> bleak.backends.device.BLEDevice</span>
</code></dt>
<dd>
<div class="desc"><p>Find a device by address.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_device(self, address: Optional[str]) -&gt; BLEDevice:
    &#34;&#34;&#34;Find a device by address.&#34;&#34;&#34;

    addressed_devices = BLEInterface.scan()

    if address:
        addressed_devices = list(
            filter(
                lambda x: address in (x.name, x.address),
                addressed_devices,
            )
        )

    if len(addressed_devices) == 0:
        raise BLEInterface.BLEError(
            f&#34;No Meshtastic BLE peripheral with identifier or address &#39;{address}&#39; found. Try --ble-scan to find it.&#34;
        )
    if len(addressed_devices) &gt; 1:
        raise BLEInterface.BLEError(
            f&#34;More than one Meshtastic BLE peripheral with identifier or address &#39;{address}&#39; found.&#34;
        )
    return addressed_devices[0]</code></pre>
</details>
</dd>
<dt id="meshtastic.ble_interface.BLEInterface.from_num_handler"><code class="name flex">
<span>def <span class="ident">from_num_handler</span></span>(<span>self, _, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle callbacks for fromnum notify.
Note: this method does not need to be async because it is just setting a bool.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_num_handler(self, _, b):  # pylint: disable=C0116
    &#34;&#34;&#34;Handle callbacks for fromnum notify.
    Note: this method does not need to be async because it is just setting a bool.
    &#34;&#34;&#34;
    from_num = struct.unpack(&#34;&lt;I&#34;, bytes(b))[0]
    logging.debug(f&#34;FROMNUM notify: {from_num}&#34;)
    self.should_read = True</code></pre>
</details>
</dd>
<dt id="meshtastic.ble_interface.BLEInterface.legacy_log_radio_handler"><code class="name flex">
<span>async def <span class="ident">legacy_log_radio_handler</span></span>(<span>self, _, b)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def legacy_log_radio_handler(self, _, b):  # pylint: disable=C0116
    log_radio = b.decode(&#34;utf-8&#34;).replace(&#34;\n&#34;, &#34;&#34;)
    self._handleLogLine(log_radio)</code></pre>
</details>
</dd>
<dt id="meshtastic.ble_interface.BLEInterface.log_radio_handler"><code class="name flex">
<span>async def <span class="ident">log_radio_handler</span></span>(<span>self, _, b)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def log_radio_handler(self, _, b):  # pylint: disable=C0116
    log_record = mesh_pb2.LogRecord()
    try:
        log_record.ParseFromString(bytes(b))

        message = (
            f&#34;[{log_record.source}] {log_record.message}&#34;
            if log_record.source
            else log_record.message
        )
        self._handleLogLine(message)
    except google.protobuf.message.DecodeError:
        logging.warning(&#34;Malformed LogRecord received. Skipping.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="meshtastic.mesh_interface.MeshInterface" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface">MeshInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="meshtastic.mesh_interface.MeshInterface.MeshInterfaceError" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.MeshInterfaceError">MeshInterfaceError</a></code></li>
<li><code><a title="meshtastic.mesh_interface.MeshInterface.close" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.close">close</a></code></li>
<li><code><a title="meshtastic.mesh_interface.MeshInterface.getLongName" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.getLongName">getLongName</a></code></li>
<li><code><a title="meshtastic.mesh_interface.MeshInterface.getMyNodeInfo" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.getMyNodeInfo">getMyNodeInfo</a></code></li>
<li><code><a title="meshtastic.mesh_interface.MeshInterface.getMyUser" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.getMyUser">getMyUser</a></code></li>
<li><code><a title="meshtastic.mesh_interface.MeshInterface.getNode" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.getNode">getNode</a></code></li>
<li><code><a title="meshtastic.mesh_interface.MeshInterface.getPublicKey" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.getPublicKey">getPublicKey</a></code></li>
<li><code><a title="meshtastic.mesh_interface.MeshInterface.getShortName" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.getShortName">getShortName</a></code></li>
<li><code><a title="meshtastic.mesh_interface.MeshInterface.onResponsePosition" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.onResponsePosition">onResponsePosition</a></code></li>
<li><code><a title="meshtastic.mesh_interface.MeshInterface.onResponseTelemetry" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.onResponseTelemetry">onResponseTelemetry</a></code></li>
<li><code><a title="meshtastic.mesh_interface.MeshInterface.onResponseTraceRoute" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.onResponseTraceRoute">onResponseTraceRoute</a></code></li>
<li><code><a title="meshtastic.mesh_interface.MeshInterface.sendData" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.sendData">sendData</a></code></li>
<li><code><a title="meshtastic.mesh_interface.MeshInterface.sendHeartbeat" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.sendHeartbeat">sendHeartbeat</a></code></li>
<li><code><a title="meshtastic.mesh_interface.MeshInterface.sendPosition" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.sendPosition">sendPosition</a></code></li>
<li><code><a title="meshtastic.mesh_interface.MeshInterface.sendTelemetry" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.sendTelemetry">sendTelemetry</a></code></li>
<li><code><a title="meshtastic.mesh_interface.MeshInterface.sendText" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.sendText">sendText</a></code></li>
<li><code><a title="meshtastic.mesh_interface.MeshInterface.sendTraceRoute" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.sendTraceRoute">sendTraceRoute</a></code></li>
<li><code><a title="meshtastic.mesh_interface.MeshInterface.showInfo" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.showInfo">showInfo</a></code></li>
<li><code><a title="meshtastic.mesh_interface.MeshInterface.showNodes" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.showNodes">showNodes</a></code></li>
<li><code><a title="meshtastic.mesh_interface.MeshInterface.waitForAckNak" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.waitForAckNak">waitForAckNak</a></code></li>
<li><code><a title="meshtastic.mesh_interface.MeshInterface.waitForConfig" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.waitForConfig">waitForConfig</a></code></li>
<li><code><a title="meshtastic.mesh_interface.MeshInterface.waitForPosition" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.waitForPosition">waitForPosition</a></code></li>
<li><code><a title="meshtastic.mesh_interface.MeshInterface.waitForTelemetry" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.waitForTelemetry">waitForTelemetry</a></code></li>
<li><code><a title="meshtastic.mesh_interface.MeshInterface.waitForTraceRoute" href="mesh_interface.html#meshtastic.mesh_interface.MeshInterface.waitForTraceRoute">waitForTraceRoute</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="meshtastic" href="index.html">meshtastic</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="meshtastic.ble_interface.BLEClient" href="#meshtastic.ble_interface.BLEClient">BLEClient</a></code></h4>
<ul class="two-column">
<li><code><a title="meshtastic.ble_interface.BLEClient.async_await" href="#meshtastic.ble_interface.BLEClient.async_await">async_await</a></code></li>
<li><code><a title="meshtastic.ble_interface.BLEClient.async_run" href="#meshtastic.ble_interface.BLEClient.async_run">async_run</a></code></li>
<li><code><a title="meshtastic.ble_interface.BLEClient.close" href="#meshtastic.ble_interface.BLEClient.close">close</a></code></li>
<li><code><a title="meshtastic.ble_interface.BLEClient.connect" href="#meshtastic.ble_interface.BLEClient.connect">connect</a></code></li>
<li><code><a title="meshtastic.ble_interface.BLEClient.disconnect" href="#meshtastic.ble_interface.BLEClient.disconnect">disconnect</a></code></li>
<li><code><a title="meshtastic.ble_interface.BLEClient.discover" href="#meshtastic.ble_interface.BLEClient.discover">discover</a></code></li>
<li><code><a title="meshtastic.ble_interface.BLEClient.has_characteristic" href="#meshtastic.ble_interface.BLEClient.has_characteristic">has_characteristic</a></code></li>
<li><code><a title="meshtastic.ble_interface.BLEClient.pair" href="#meshtastic.ble_interface.BLEClient.pair">pair</a></code></li>
<li><code><a title="meshtastic.ble_interface.BLEClient.read_gatt_char" href="#meshtastic.ble_interface.BLEClient.read_gatt_char">read_gatt_char</a></code></li>
<li><code><a title="meshtastic.ble_interface.BLEClient.start_notify" href="#meshtastic.ble_interface.BLEClient.start_notify">start_notify</a></code></li>
<li><code><a title="meshtastic.ble_interface.BLEClient.write_gatt_char" href="#meshtastic.ble_interface.BLEClient.write_gatt_char">write_gatt_char</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="meshtastic.ble_interface.BLEInterface" href="#meshtastic.ble_interface.BLEInterface">BLEInterface</a></code></h4>
<ul class="">
<li><code><a title="meshtastic.ble_interface.BLEInterface.BLEError" href="#meshtastic.ble_interface.BLEInterface.BLEError">BLEError</a></code></li>
<li><code><a title="meshtastic.ble_interface.BLEInterface.connect" href="#meshtastic.ble_interface.BLEInterface.connect">connect</a></code></li>
<li><code><a title="meshtastic.ble_interface.BLEInterface.find_device" href="#meshtastic.ble_interface.BLEInterface.find_device">find_device</a></code></li>
<li><code><a title="meshtastic.ble_interface.BLEInterface.from_num_handler" href="#meshtastic.ble_interface.BLEInterface.from_num_handler">from_num_handler</a></code></li>
<li><code><a title="meshtastic.ble_interface.BLEInterface.legacy_log_radio_handler" href="#meshtastic.ble_interface.BLEInterface.legacy_log_radio_handler">legacy_log_radio_handler</a></code></li>
<li><code><a title="meshtastic.ble_interface.BLEInterface.log_radio_handler" href="#meshtastic.ble_interface.BLEInterface.log_radio_handler">log_radio_handler</a></code></li>
<li><code><a title="meshtastic.ble_interface.BLEInterface.scan" href="#meshtastic.ble_interface.BLEInterface.scan">scan</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>