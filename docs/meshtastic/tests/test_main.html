<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>meshtastic.tests.test_main API documentation</title>
<meta name="description" content="Meshtastic unit tests for __main__.py" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>meshtastic.tests.test_main</code></h1>
</header>
<section id="section-intro">
<p>Meshtastic unit tests for <strong>main</strong>.py</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Meshtastic unit tests for __main__.py&#34;&#34;&#34;
# pylint: disable=C0302,W0613

import logging
import os
import platform
import re
import sys
from unittest.mock import mock_open, MagicMock, patch

import pytest

from meshtastic.__main__ import (
    export_config,
    initParser,
    main,
    onConnection,
    onNode,
    onReceive,
    tunnelMain,
)
from meshtastic import mt_config

from ..protobuf.channel_pb2 import Channel # pylint: disable=E0611

# from ..ble_interface import BLEInterface
from ..node import Node

# from ..radioconfig_pb2 import UserPreferences
# import meshtastic.config_pb2
from ..serial_interface import SerialInterface
from ..tcp_interface import TCPInterface

# from ..remote_hardware import onGPIOreceive
# from ..config_pb2 import Config


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_init_parser_no_args(capsys):
    &#34;&#34;&#34;Test no arguments&#34;&#34;&#34;
    sys.argv = [&#34;&#34;]
    mt_config.args = sys.argv
    initParser()
    out, err = capsys.readouterr()
    assert out == &#34;&#34;
    assert err == &#34;&#34;


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_init_parser_version(capsys):
    &#34;&#34;&#34;Test --version&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--version&#34;]
    mt_config.args = sys.argv

    with pytest.raises(SystemExit) as pytest_wrapped_e:
        initParser()
    assert pytest_wrapped_e.type == SystemExit
    assert pytest_wrapped_e.value.code == 0
    out, err = capsys.readouterr()
    assert re.match(r&#34;[0-9]+\.[0-9]+[\.a][0-9]&#34;, out)
    assert err == &#34;&#34;


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_main_version(capsys):
    &#34;&#34;&#34;Test --version&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--version&#34;]
    mt_config.args = sys.argv

    with pytest.raises(SystemExit) as pytest_wrapped_e:
        main()
    assert pytest_wrapped_e.type == SystemExit
    assert pytest_wrapped_e.value.code == 0
    out, err = capsys.readouterr()
    assert re.match(r&#34;[0-9]+\.[0-9]+[\.a][0-9]&#34;, out)
    assert err == &#34;&#34;


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_main_no_args(capsys):
    &#34;&#34;&#34;Test with no args&#34;&#34;&#34;
    sys.argv = [&#34;&#34;]
    mt_config.args = sys.argv

    with pytest.raises(SystemExit) as pytest_wrapped_e:
        main()
    assert pytest_wrapped_e.type == SystemExit
    assert pytest_wrapped_e.value.code == 1
    _, err = capsys.readouterr()
    assert re.search(r&#34;usage:&#34;, err, re.MULTILINE)


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_support(capsys):
    &#34;&#34;&#34;Test --support&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--support&#34;]
    mt_config.args = sys.argv

    with pytest.raises(SystemExit) as pytest_wrapped_e:
        main()
    assert pytest_wrapped_e.type == SystemExit
    assert pytest_wrapped_e.value.code == 0
    out, err = capsys.readouterr()
    assert re.search(r&#34;System&#34;, out, re.MULTILINE)
    assert re.search(r&#34;Platform&#34;, out, re.MULTILINE)
    assert re.search(r&#34;Machine&#34;, out, re.MULTILINE)
    assert re.search(r&#34;Executable&#34;, out, re.MULTILINE)
    assert err == &#34;&#34;


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[])
def test_main_ch_index_no_devices(patched_find_ports, capsys):
    &#34;&#34;&#34;Test --ch-index 1&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-index&#34;, &#34;1&#34;]
    mt_config.args = sys.argv

    with pytest.raises(SystemExit) as pytest_wrapped_e:
        main()
    assert mt_config.channel_index == 1
    assert pytest_wrapped_e.type == SystemExit
    assert pytest_wrapped_e.value.code == 1
    out, err = capsys.readouterr()
    assert re.search(r&#34;No.*Meshtastic.*device.*detected&#34;, out, re.MULTILINE)
    assert err == &#34;&#34;
    patched_find_ports.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[])
def test_main_test_no_ports(patched_find_ports, capsys):
    &#34;&#34;&#34;Test --test with no hardware&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--test&#34;]
    mt_config.args = sys.argv

    with pytest.raises(SystemExit) as pytest_wrapped_e:
        main()
    assert pytest_wrapped_e.type == SystemExit
    assert pytest_wrapped_e.value.code == 1
    patched_find_ports.assert_called()
    out, err = capsys.readouterr()
    assert re.search(
        r&#34;Warning: Must have at least two devices connected to USB&#34;, out, re.MULTILINE
    )
    assert err == &#34;&#34;


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[&#34;/dev/ttyFake1&#34;])
def test_main_test_one_port(patched_find_ports, capsys):
    &#34;&#34;&#34;Test --test with one fake port&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--test&#34;]
    mt_config.args = sys.argv

    with pytest.raises(SystemExit) as pytest_wrapped_e:
        main()
    assert pytest_wrapped_e.type == SystemExit
    assert pytest_wrapped_e.value.code == 1
    patched_find_ports.assert_called()
    out, err = capsys.readouterr()
    assert re.search(
        r&#34;Warning: Must have at least two devices connected to USB&#34;, out, re.MULTILINE
    )
    assert err == &#34;&#34;


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;meshtastic.test.testAll&#34;, return_value=True)
def test_main_test_two_ports_success(patched_test_all, capsys):
    &#34;&#34;&#34;Test --test two fake ports and testAll() is a simulated success&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--test&#34;]
    mt_config.args = sys.argv

    with pytest.raises(SystemExit) as pytest_wrapped_e:
        main()
    assert pytest_wrapped_e.type == SystemExit
    assert pytest_wrapped_e.value.code == 0
    patched_test_all.assert_called()
    out, err = capsys.readouterr()
    assert re.search(r&#34;Test was a success.&#34;, out, re.MULTILINE)
    assert err == &#34;&#34;


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;meshtastic.test.testAll&#34;, return_value=False)
def test_main_test_two_ports_fails(patched_test_all, capsys):
    &#34;&#34;&#34;Test --test two fake ports and testAll() is a simulated failure&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--test&#34;]
    mt_config.args = sys.argv

    with pytest.raises(SystemExit) as pytest_wrapped_e:
        main()
    assert pytest_wrapped_e.type == SystemExit
    assert pytest_wrapped_e.value.code == 1
    patched_test_all.assert_called()
    out, err = capsys.readouterr()
    assert re.search(r&#34;Test was not successful.&#34;, out, re.MULTILINE)
    assert err == &#34;&#34;


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_info(capsys, caplog):
    &#34;&#34;&#34;Test --info&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--info&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)

    def mock_showInfo():
        print(&#34;inside mocked showInfo&#34;)

    iface.showInfo.side_effect = mock_showInfo
    with caplog.at_level(logging.DEBUG):
        with patch(
            &#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface
        ) as mo:
            main()
            out, err = capsys.readouterr()
            assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
            assert re.search(r&#34;inside mocked showInfo&#34;, out, re.MULTILINE)
            assert err == &#34;&#34;
            mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;os.getlogin&#34;)
def test_main_info_with_permission_error(patched_getlogin, capsys, caplog):
    &#34;&#34;&#34;Test --info&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--info&#34;]
    mt_config.args = sys.argv

    patched_getlogin.return_value = &#34;me&#34;

    iface = MagicMock(autospec=SerialInterface)
    with caplog.at_level(logging.DEBUG):
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            with patch(
                &#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface
            ) as mo:
                mo.side_effect = PermissionError(&#34;bla bla&#34;)
                main()
            assert pytest_wrapped_e.type == SystemExit
            assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        patched_getlogin.assert_called()
        assert re.search(r&#34;Need to add yourself&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_info_with_tcp_interface(capsys):
    &#34;&#34;&#34;Test --info&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--info&#34;, &#34;--host&#34;, &#34;meshtastic.local&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=TCPInterface)

    def mock_showInfo():
        print(&#34;inside mocked showInfo&#34;)

    iface.showInfo.side_effect = mock_showInfo
    with patch(&#34;meshtastic.tcp_interface.TCPInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked showInfo&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_no_proto(capsys):
    &#34;&#34;&#34;Test --noproto (using --info for output)&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--info&#34;, &#34;--noproto&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)

    def mock_showInfo():
        print(&#34;inside mocked showInfo&#34;)

    iface.showInfo.side_effect = mock_showInfo

    # Override the time.sleep so there is no loop
    def my_sleep(amount):
        print(f&#34;amount:{amount}&#34;)
        sys.exit(0)

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface):
        with patch(&#34;time.sleep&#34;, side_effect=my_sleep):
            with pytest.raises(SystemExit) as pytest_wrapped_e:
                main()
            assert pytest_wrapped_e.type == SystemExit
            assert pytest_wrapped_e.value.code == 0
            out, err = capsys.readouterr()
            assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
            assert re.search(r&#34;inside mocked showInfo&#34;, out, re.MULTILINE)
            assert err == &#34;&#34;


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_info_with_seriallog_stdout(capsys):
    &#34;&#34;&#34;Test --info&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--info&#34;, &#34;--seriallog&#34;, &#34;stdout&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)

    def mock_showInfo():
        print(&#34;inside mocked showInfo&#34;)

    iface.showInfo.side_effect = mock_showInfo
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked showInfo&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_info_with_seriallog_output_txt(capsys):
    &#34;&#34;&#34;Test --info&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--info&#34;, &#34;--seriallog&#34;, &#34;output.txt&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)

    def mock_showInfo():
        print(&#34;inside mocked showInfo&#34;)

    iface.showInfo.side_effect = mock_showInfo
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked showInfo&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()
    # do some cleanup
    os.remove(&#34;output.txt&#34;)


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_qr(capsys):
    &#34;&#34;&#34;Test --qr&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--qr&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)
    # TODO: could mock/check url
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Primary channel URL&#34;, out, re.MULTILINE)
        # if a qr code is generated it will have lots of these
        assert re.search(r&#34;\[7m&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_onConnected_exception(capsys):
    &#34;&#34;&#34;Test the exception in onConnected&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--qr&#34;]
    mt_config.args = sys.argv

    def throw_an_exception(junk):
        raise Exception(&#34;Fake exception.&#34;) # pylint: disable=W0719

    iface = MagicMock(autospec=SerialInterface)
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface):
        with patch(&#34;pyqrcode.create&#34;, side_effect=throw_an_exception):
            with pytest.raises(SystemExit) as pytest_wrapped_e:
                main()
                out, err = capsys.readouterr()
                assert re.search(&#34;Aborting due to: Fake exception&#34;, out, re.MULTILINE)
                assert err == &#34;&#34;
                assert pytest_wrapped_e.type == Exception


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_nodes(capsys):
    &#34;&#34;&#34;Test --nodes&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--nodes&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)

    def mock_showNodes():
        print(&#34;inside mocked showNodes&#34;)

    iface.showNodes.side_effect = mock_showNodes
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked showNodes&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_set_owner_to_bob(capsys):
    &#34;&#34;&#34;Test --set-owner bob&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--set-owner&#34;, &#34;bob&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Setting device owner to bob&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_set_owner_short_to_bob(capsys):
    &#34;&#34;&#34;Test --set-owner-short bob&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--set-owner-short&#34;, &#34;bob&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Setting device owner short to bob&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_set_canned_messages(capsys):
    &#34;&#34;&#34;Test --set-canned-message&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--set-canned-message&#34;, &#34;foo&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Setting canned plugin message to foo&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_get_canned_messages(capsys, caplog, iface_with_nodes):
    &#34;&#34;&#34;Test --get-canned-message&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--get-canned-message&#34;]
    mt_config.args = sys.argv

    iface = iface_with_nodes
    iface.localNode.cannedPluginMessage = &#34;foo&#34;
    iface.devPath = &#34;bar&#34;

    with caplog.at_level(logging.DEBUG):
        with patch(
            &#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface
        ) as mo:
            main()
            out, err = capsys.readouterr()
            assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
            assert re.search(r&#34;canned_plugin_message:foo&#34;, out, re.MULTILINE)
            assert err == &#34;&#34;
            mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_set_ham_to_KI123(capsys):
    &#34;&#34;&#34;Test --set-ham KI123&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--set-ham&#34;, &#34;KI123&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    def mock_turnOffEncryptionOnPrimaryChannel():
        print(&#34;inside mocked turnOffEncryptionOnPrimaryChannel&#34;)

    def mock_setOwner(name, is_licensed):
        print(f&#34;inside mocked setOwner name:{name} is_licensed:{is_licensed}&#34;)

    mocked_node.turnOffEncryptionOnPrimaryChannel.side_effect = (
        mock_turnOffEncryptionOnPrimaryChannel
    )
    mocked_node.setOwner.side_effect = mock_setOwner

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Setting Ham ID to KI123&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked setOwner&#34;, out, re.MULTILINE)
        assert re.search(
            r&#34;inside mocked turnOffEncryptionOnPrimaryChannel&#34;, out, re.MULTILINE
        )
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_reboot(capsys):
    &#34;&#34;&#34;Test --reboot&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--reboot&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    def mock_reboot():
        print(&#34;inside mocked reboot&#34;)

    mocked_node.reboot.side_effect = mock_reboot

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked reboot&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_shutdown(capsys):
    &#34;&#34;&#34;Test --shutdown&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--shutdown&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    def mock_shutdown():
        print(&#34;inside mocked shutdown&#34;)

    mocked_node.shutdown.side_effect = mock_shutdown

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked shutdown&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_sendtext(capsys):
    &#34;&#34;&#34;Test --sendtext&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--sendtext&#34;, &#34;hello&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)

    def mock_sendText(
        text, dest, wantAck=False, wantResponse=False, onResponse=None, channelIndex=0
    ):
        print(&#34;inside mocked sendText&#34;)
        print(f&#34;{text} {dest} {wantAck} {wantResponse} {channelIndex}&#34;)

    iface.sendText.side_effect = mock_sendText

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Sending text message&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked sendText&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_sendtext_with_channel(capsys):
    &#34;&#34;&#34;Test --sendtext&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--sendtext&#34;, &#34;hello&#34;, &#34;--ch-index&#34;, &#34;1&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)

    def mock_sendText(
        text, dest, wantAck=False, wantResponse=False, onResponse=None, channelIndex=0
    ):
        print(&#34;inside mocked sendText&#34;)
        print(f&#34;{text} {dest} {wantAck} {wantResponse} {channelIndex}&#34;)

    iface.sendText.side_effect = mock_sendText

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Sending text message&#34;, out, re.MULTILINE)
        assert re.search(r&#34;on channelIndex:1&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked sendText&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_sendtext_with_invalid_channel(caplog, capsys):
    &#34;&#34;&#34;Test --sendtext&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--sendtext&#34;, &#34;hello&#34;, &#34;--ch-index&#34;, &#34;-1&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)
    iface.localNode.getChannelByChannelIndex.return_value = None

    with caplog.at_level(logging.DEBUG):
        with patch(
            &#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface
        ) as mo:
            with pytest.raises(SystemExit) as pytest_wrapped_e:
                main()
            assert pytest_wrapped_e.type == SystemExit
            assert pytest_wrapped_e.value.code == 1
            out, err = capsys.readouterr()
            assert re.search(r&#34;is not a valid channel&#34;, out, re.MULTILINE)
            assert err == &#34;&#34;
            mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_sendtext_with_invalid_channel_nine(caplog, capsys):
    &#34;&#34;&#34;Test --sendtext&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--sendtext&#34;, &#34;hello&#34;, &#34;--ch-index&#34;, &#34;9&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)
    iface.localNode.getChannelByChannelIndex.return_value = None

    with caplog.at_level(logging.DEBUG):
        with patch(
            &#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface
        ) as mo:
            with pytest.raises(SystemExit) as pytest_wrapped_e:
                main()
            assert pytest_wrapped_e.type == SystemExit
            assert pytest_wrapped_e.value.code == 1
            out, err = capsys.readouterr()
            assert re.search(r&#34;is not a valid channel&#34;, out, re.MULTILINE)
            assert err == &#34;&#34;
            mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;termios.tcsetattr&#34;)
@patch(&#34;termios.tcgetattr&#34;)
@patch(&#34;builtins.open&#34;, new_callable=mock_open, read_data=&#34;data&#34;)
@patch(&#34;serial.Serial&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[&#34;/dev/ttyUSBfake&#34;])
def test_main_sendtext_with_dest(mock_findPorts, mock_serial, mocked_open, mock_get, mock_set, capsys, caplog, iface_with_nodes):
    &#34;&#34;&#34;Test --sendtext with --dest&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--sendtext&#34;, &#34;hello&#34;, &#34;--dest&#34;, &#34;foo&#34;]
    mt_config.args = sys.argv

    #iface = iface_with_nodes
    #iface.myInfo.my_node_num = 2475227164
    serialInterface = SerialInterface(noProto=True)

    mocked_channel = MagicMock(autospec=Channel)
    serialInterface.localNode.getChannelByChannelIndex = mocked_channel

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=serialInterface):
        with caplog.at_level(logging.DEBUG):
            #with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
            #assert pytest_wrapped_e.type == SystemExit
            #assert pytest_wrapped_e.value.code == 1
            out, err = capsys.readouterr()
            assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
            assert not re.search(
                r&#34;Warning: 0 is not a valid channel&#34;, out, re.MULTILINE
            )
            assert not re.search(
                r&#34;There is a SECONDARY channel named &#39;admin&#39;&#34;, out, re.MULTILINE
            )
            print(out)
            assert re.search(r&#34;Not sending packet because&#34;, caplog.text, re.MULTILINE)
            assert re.search(r&#34;Warning: There were no self.nodes.&#34;, caplog.text, re.MULTILINE)
            assert err == &#34;&#34;

@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_removeposition_remote(capsys):
    &#34;&#34;&#34;Test --remove-position with a remote dest&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--remove-position&#34;, &#34;--dest&#34;, &#34;!12345678&#34;]
    mt_config.args = sys.argv
    iface = MagicMock(autospec=SerialInterface)
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Removing fixed position and disabling fixed position setting&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Waiting for an acknowledgment from remote node&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()

@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_setlat_remote(capsys):
    &#34;&#34;&#34;Test --setlat with a remote dest&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--setlat&#34;, &#34;37.5&#34;, &#34;--dest&#34;, &#34;!12345678&#34;]
    mt_config.args = sys.argv
    iface = MagicMock(autospec=SerialInterface)
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Setting device position and enabling fixed position setting&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Waiting for an acknowledgment from remote node&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()

@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_removeposition(capsys):
    &#34;&#34;&#34;Test --remove-position&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--remove-position&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    def mock_removeFixedPosition():
        print(&#34;inside mocked removeFixedPosition&#34;)

    mocked_node.removeFixedPosition.side_effect = mock_removeFixedPosition

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Removing fixed position&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked removeFixedPosition&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()

@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_setlat(capsys):
    &#34;&#34;&#34;Test --setlat&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--setlat&#34;, &#34;37.5&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    def mock_setFixedPosition(lat, lon, alt):
        print(&#34;inside mocked setFixedPosition&#34;)
        print(f&#34;{lat} {lon} {alt}&#34;)

    mocked_node.setFixedPosition.side_effect = mock_setFixedPosition

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Fixing latitude&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Setting device position&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked setFixedPosition&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_setlon(capsys):
    &#34;&#34;&#34;Test --setlon&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--setlon&#34;, &#34;-122.1&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    def mock_setFixedPosition(lat, lon, alt):
        print(&#34;inside mocked setFixedPosition&#34;)
        print(f&#34;{lat} {lon} {alt}&#34;)

    mocked_node.setFixedPosition.side_effect = mock_setFixedPosition

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Fixing longitude&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Setting device position&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked setFixedPosition&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_setalt(capsys):
    &#34;&#34;&#34;Test --setalt&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--setalt&#34;, &#34;51&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    def mock_setFixedPosition(lat, lon, alt):
        print(&#34;inside mocked setFixedPosition&#34;)
        print(f&#34;{lat} {lon} {alt}&#34;)

    mocked_node.setFixedPosition.side_effect = mock_setFixedPosition

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Fixing altitude&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Setting device position&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked setFixedPosition&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_seturl(capsys):
    &#34;&#34;&#34;Test --seturl (url used below is what is generated after a factory_reset)&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--seturl&#34;, &#34;https://www.meshtastic.org/d/#CgUYAyIBAQ&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;termios.tcsetattr&#34;)
@patch(&#34;termios.tcgetattr&#34;)
@patch(&#34;builtins.open&#34;, new_callable=mock_open, read_data=&#34;data&#34;)
@patch(&#34;serial.Serial&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[&#34;/dev/ttyUSBfake&#34;])
def test_main_set_valid(mocked_findports, mocked_serial, mocked_open, mocked_get, mocked_set, capsys):
    &#34;&#34;&#34;Test --set with valid field&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--set&#34;, &#34;network.wifi_ssid&#34;, &#34;foo&#34;]
    mt_config.args = sys.argv

    serialInterface = SerialInterface(noProto=True)
    anode = Node(serialInterface, 1234567890, noProto=True)
    serialInterface.localNode = anode

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=serialInterface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Set network.wifi_ssid to foo&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;termios.tcsetattr&#34;)
@patch(&#34;termios.tcgetattr&#34;)
@patch(&#34;builtins.open&#34;, new_callable=mock_open, read_data=&#34;data&#34;)
@patch(&#34;serial.Serial&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[&#34;/dev/ttyUSBfake&#34;])
def test_main_set_valid_wifi_psk(mocked_findports, mocked_serial, mocked_open, mocked_get, mocked_set, capsys):
    &#34;&#34;&#34;Test --set with valid field&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--set&#34;, &#34;network.wifi_psk&#34;, &#34;123456789&#34;]
    mt_config.args = sys.argv

    serialInterface = SerialInterface(noProto=True)
    anode = Node(serialInterface, 1234567890, noProto=True)
    serialInterface.localNode = anode

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=serialInterface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Set network.wifi_psk to 123456789&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;termios.tcsetattr&#34;)
@patch(&#34;termios.tcgetattr&#34;)
@patch(&#34;builtins.open&#34;, new_callable=mock_open, read_data=&#34;data&#34;)
@patch(&#34;serial.Serial&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[&#34;/dev/ttyUSBfake&#34;])
def test_main_set_invalid_wifi_psk(mocked_findports, mocked_serial, mocked_open, mocked_get, mocked_set, capsys):
    &#34;&#34;&#34;Test --set with an invalid value (psk must be 8 or more characters)&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--set&#34;, &#34;network.wifi_psk&#34;, &#34;1234567&#34;]
    mt_config.args = sys.argv

    serialInterface = SerialInterface(noProto=True)
    anode = Node(serialInterface, 1234567890, noProto=True)
    serialInterface.localNode = anode

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=serialInterface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert not re.search(r&#34;Set network.wifi_psk to 1234567&#34;, out, re.MULTILINE)
        assert re.search(
            r&#34;Warning: network.wifi_psk must be 8 or more characters.&#34;, out, re.MULTILINE
        )
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;termios.tcsetattr&#34;)
@patch(&#34;termios.tcgetattr&#34;)
@patch(&#34;builtins.open&#34;, new_callable=mock_open, read_data=&#34;data&#34;)
@patch(&#34;serial.Serial&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[&#34;/dev/ttyUSBfake&#34;])
def test_main_set_valid_camel_case(mocked_findports, mocked_serial, mocked_open, mocked_get, mocked_set, capsys):
    &#34;&#34;&#34;Test --set with valid field&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--set&#34;, &#34;network.wifi_ssid&#34;, &#34;foo&#34;]
    mt_config.args = sys.argv
    mt_config.camel_case = True

    serialInterface = SerialInterface(noProto=True)
    anode = Node(serialInterface, 1234567890, noProto=True)
    serialInterface.localNode = anode

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=serialInterface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Set network.wifiSsid to foo&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;termios.tcsetattr&#34;)
@patch(&#34;termios.tcgetattr&#34;)
@patch(&#34;builtins.open&#34;, new_callable=mock_open, read_data=&#34;data&#34;)
@patch(&#34;serial.Serial&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[&#34;/dev/ttyUSBfake&#34;])
def test_main_set_with_invalid(mocked_findports, mocked_serial, mocked_open, mocked_get, mocked_set, capsys):
    &#34;&#34;&#34;Test --set with invalid field&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--set&#34;, &#34;foo&#34;, &#34;foo&#34;]
    mt_config.args = sys.argv

    serialInterface = SerialInterface(noProto=True)
    anode = Node(serialInterface, 1234567890, noProto=True)
    serialInterface.localNode = anode

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=serialInterface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;do not have attribute foo&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


# TODO: write some negative --configure tests
@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;termios.tcsetattr&#34;)
@patch(&#34;termios.tcgetattr&#34;)
@patch(&#34;builtins.open&#34;, new_callable=mock_open, read_data=&#34;data&#34;)
@patch(&#34;serial.Serial&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[&#34;/dev/ttyUSBfake&#34;])
def test_main_configure_with_snake_case(mocked_findports, mocked_serial, mocked_open, mocked_get, mocked_set, capsys):
    &#34;&#34;&#34;Test --configure with valid file&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--configure&#34;, &#34;example_config.yaml&#34;]
    mt_config.args = sys.argv

    serialInterface = SerialInterface(noProto=True)
    anode = Node(serialInterface, 1234567890, noProto=True)
    serialInterface.localNode = anode

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=serialInterface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        # should these come back? maybe a flag?
        #assert re.search(r&#34;Setting device owner&#34;, out, re.MULTILINE)
        #assert re.search(r&#34;Setting device owner short&#34;, out, re.MULTILINE)
        #assert re.search(r&#34;Setting channel url&#34;, out, re.MULTILINE)
        #assert re.search(r&#34;Fixing altitude&#34;, out, re.MULTILINE)
        #assert re.search(r&#34;Fixing latitude&#34;, out, re.MULTILINE)
        #assert re.search(r&#34;Fixing longitude&#34;, out, re.MULTILINE)
        #assert re.search(r&#34;Set location_share to LocEnabled&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Writing modified configuration to device&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;termios.tcsetattr&#34;)
@patch(&#34;termios.tcgetattr&#34;)
@patch(&#34;builtins.open&#34;, new_callable=mock_open, read_data=&#34;data&#34;)
@patch(&#34;serial.Serial&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[&#34;/dev/ttyUSBfake&#34;])
def test_main_configure_with_camel_case_keys(mocked_findports, mocked_serial, mocked_open, mocked_get, mocked_set, capsys):
    &#34;&#34;&#34;Test --configure with valid file&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--configure&#34;, &#34;exampleConfig.yaml&#34;]
    mt_config.args = sys.argv

    serialInterface = SerialInterface(noProto=True)
    anode = Node(serialInterface, 1234567890, noProto=True)
    serialInterface.localNode = anode

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=serialInterface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        # should these come back? maybe a flag?
        #assert re.search(r&#34;Setting device owner&#34;, out, re.MULTILINE)
        #assert re.search(r&#34;Setting device owner short&#34;, out, re.MULTILINE)
        #assert re.search(r&#34;Setting channel url&#34;, out, re.MULTILINE)
        #assert re.search(r&#34;Fixing altitude&#34;, out, re.MULTILINE)
        #assert re.search(r&#34;Fixing latitude&#34;, out, re.MULTILINE)
        #assert re.search(r&#34;Fixing longitude&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Writing modified configuration to device&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_add_valid(capsys):
    &#34;&#34;&#34;Test --ch-add with valid channel name, and that channel name does not already exist&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-add&#34;, &#34;testing&#34;]
    mt_config.args = sys.argv

    mocked_channel = MagicMock(autospec=Channel)
    # TODO: figure out how to get it to print the channel name instead of MagicMock

    mocked_node = MagicMock(autospec=Node)
    # set it up so we do not already have a channel named this
    mocked_node.getChannelByName.return_value = False
    # set it up so we have free channels
    mocked_node.getDisabledChannel.return_value = mocked_channel

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Writing modified channels to device&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_add_invalid_name_too_long(capsys):
    &#34;&#34;&#34;Test --ch-add with invalid channel name, name too long&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-add&#34;, &#34;testingtestingtesting&#34;]
    mt_config.args = sys.argv

    mocked_channel = MagicMock(autospec=Channel)
    # TODO: figure out how to get it to print the channel name instead of MagicMock

    mocked_node = MagicMock(autospec=Node)
    # set it up so we do not already have a channel named this
    mocked_node.getChannelByName.return_value = False
    # set it up so we have free channels
    mocked_node.getDisabledChannel.return_value = mocked_channel

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Warning: Channel name must be shorter&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_add_but_name_already_exists(capsys):
    &#34;&#34;&#34;Test --ch-add with a channel name that already exists&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-add&#34;, &#34;testing&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)
    # set it up so we do not already have a channel named this
    mocked_node.getChannelByName.return_value = True

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Warning: This node already has&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_add_but_no_more_channels(capsys):
    &#34;&#34;&#34;Test --ch-add with but there are no more channels&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-add&#34;, &#34;testing&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)
    # set it up so we do not already have a channel named this
    mocked_node.getChannelByName.return_value = False
    # set it up so we have free channels
    mocked_node.getDisabledChannel.return_value = None

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Warning: No free channels were found&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_del(capsys):
    &#34;&#34;&#34;Test --ch-del with valid secondary channel to be deleted&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-del&#34;, &#34;--ch-index&#34;, &#34;1&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Deleting channel&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_del_no_ch_index_specified(capsys):
    &#34;&#34;&#34;Test --ch-del without a valid ch-index&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-del&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Warning: Need to specify&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_del_primary_channel(capsys):
    &#34;&#34;&#34;Test --ch-del on ch-index=0&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-del&#34;, &#34;--ch-index&#34;, &#34;0&#34;]
    mt_config.args = sys.argv
    mt_config.channel_index = 1

    mocked_node = MagicMock(autospec=Node)

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Warning: Cannot delete primary channel&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_enable_valid_secondary_channel(capsys):
    &#34;&#34;&#34;Test --ch-enable with --ch-index&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-enable&#34;, &#34;--ch-index&#34;, &#34;1&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Writing modified channels&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        assert mt_config.channel_index == 1
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_disable_valid_secondary_channel(capsys):
    &#34;&#34;&#34;Test --ch-disable with --ch-index&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-disable&#34;, &#34;--ch-index&#34;, &#34;1&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Writing modified channels&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        assert mt_config.channel_index == 1
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_enable_without_a_ch_index(capsys):
    &#34;&#34;&#34;Test --ch-enable without --ch-index&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-enable&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Warning: Need to specify&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        assert mt_config.channel_index is None
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_enable_primary_channel(capsys):
    &#34;&#34;&#34;Test --ch-enable with --ch-index = 0&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-enable&#34;, &#34;--ch-index&#34;, &#34;0&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Warning: Cannot enable/disable PRIMARY&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        assert mt_config.channel_index == 0
        mo.assert_called()


# TODO
# @pytest.mark.unit
# @pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
# def test_main_ch_range_options(capsys):
#    &#34;&#34;&#34;Test changing the various range options.&#34;&#34;&#34;
#    range_options = [&#39;--ch-vlongslow&#39;, &#39;--ch-longslow&#39;, &#39;--ch-longfast&#39;, &#39;--ch-midslow&#39;,
#                     &#39;--ch-midfast&#39;, &#39;--ch-shortslow&#39;, &#39;--ch-shortfast&#39;]
#    for range_option in range_options:
#        sys.argv = [&#39;&#39;, f&#34;{range_option}&#34; ]
#        mt_config.args = sys.argv
#
#        mocked_node = MagicMock(autospec=Node)
#
#        iface = MagicMock(autospec=SerialInterface)
#        iface.getNode.return_value = mocked_node
#
#        with patch(&#39;meshtastic.serial_interface.SerialInterface&#39;, return_value=iface) as mo:
#            main()
#            out, err = capsys.readouterr()
#            assert re.search(r&#39;Connected to radio&#39;, out, re.MULTILINE)
#            assert re.search(r&#39;Writing modified channels&#39;, out, re.MULTILINE)
#            assert err == &#39;&#39;
#            mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_longfast_on_non_primary_channel(capsys):
    &#34;&#34;&#34;Test --ch-longfast --ch-index 1&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-longfast&#34;, &#34;--ch-index&#34;, &#34;1&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Warning: Cannot set modem preset for non-primary channel&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


# PositionFlags:
# Misc info that might be helpful (this info will grow stale, just
# a snapshot of the values.) The radioconfig_pb2.PositionFlags.Name and bit values are:
# POS_UNDEFINED 0
# POS_ALTITUDE 1
# POS_ALT_MSL 2
# POS_GEO_SEP 4
# POS_DOP 8
# POS_HVDOP 16
# POS_BATTERY 32
# POS_SATINVIEW 64
# POS_SEQ_NOS 128
# POS_TIMESTAMP 256

# TODO
# @pytest.mark.unit
# @pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
# def test_main_pos_fields_no_args(capsys):
#    &#34;&#34;&#34;Test --pos-fields no args (which shows settings)&#34;&#34;&#34;
#    sys.argv = [&#39;&#39;, &#39;--pos-fields&#39;]
#    mt_config.args = sys.argv
#
#    pos_flags = MagicMock(autospec=meshtastic.radioconfig_pb2.PositionFlags)
#
#    with patch(&#39;meshtastic.serial_interface.SerialInterface&#39;) as mo:
#        mo().getNode().radioConfig.preferences.position_flags = 35
#        with patch(&#39;meshtastic.radioconfig_pb2.PositionFlags&#39;, return_value=pos_flags) as mrc:
#
#            mrc.values.return_value = [0, 1, 2, 4, 8, 16, 32, 64, 128, 256]
#            # Note: When you use side_effect and a list, each call will use a value from the front of the list then
#            # remove that value from the list. If there are three values in the list, we expect it to be called
#            # three times.
#            mrc.Name.side_effect = [&#39;POS_ALTITUDE&#39;, &#39;POS_ALT_MSL&#39;, &#39;POS_BATTERY&#39;]
#
#            main()
#
#            mrc.Name.assert_called()
#            mrc.values.assert_called()
#            mo.assert_called()
#
#            out, err = capsys.readouterr()
#            assert re.search(r&#39;Connected to radio&#39;, out, re.MULTILINE)
#            assert re.search(r&#39;POS_ALTITUDE POS_ALT_MSL POS_BATTERY&#39;, out, re.MULTILINE)
#            assert err == &#39;&#39;


# TODO
# @pytest.mark.unit
# @pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
# def test_main_pos_fields_arg_of_zero(capsys):
#    &#34;&#34;&#34;Test --pos-fields an arg of 0 (which shows list)&#34;&#34;&#34;
#    sys.argv = [&#39;&#39;, &#39;--pos-fields&#39;, &#39;0&#39;]
#    mt_config.args = sys.argv
#
#    pos_flags = MagicMock(autospec=meshtastic.radioconfig_pb2.PositionFlags)
#
#    with patch(&#39;meshtastic.serial_interface.SerialInterface&#39;) as mo:
#        with patch(&#39;meshtastic.radioconfig_pb2.PositionFlags&#39;, return_value=pos_flags) as mrc:
#
#            def throw_value_error_exception(exc):
#                raise ValueError()
#            mrc.Value.side_effect = throw_value_error_exception
#            mrc.keys.return_value = [ &#39;POS_UNDEFINED&#39;, &#39;POS_ALTITUDE&#39;, &#39;POS_ALT_MSL&#39;,
#                                      &#39;POS_GEO_SEP&#39;, &#39;POS_DOP&#39;, &#39;POS_HVDOP&#39;, &#39;POS_BATTERY&#39;,
#                                      &#39;POS_SATINVIEW&#39;, &#39;POS_SEQ_NOS&#39;, &#39;POS_TIMESTAMP&#39;]
#
#            main()
#
#            mrc.Value.assert_called()
#            mrc.keys.assert_called()
#            mo.assert_called()
#
#            out, err = capsys.readouterr()
#            assert re.search(r&#39;Connected to radio&#39;, out, re.MULTILINE)
#            assert re.search(r&#39;ERROR: supported position fields are:&#39;, out, re.MULTILINE)
#            assert re.search(r&#34;[&#39;POS_UNDEFINED&#39;, &#39;POS_ALTITUDE&#39;, &#39;POS_ALT_MSL&#39;, &#39;POS_GEO_SEP&#39;,&#34;\
#                              &#34;&#39;POS_DOP&#39;, &#39;POS_HVDOP&#39;, &#39;POS_BATTERY&#39;, &#39;POS_SATINVIEW&#39;, &#39;POS_SEQ_NOS&#39;,&#34;\
#                              &#34;&#39;POS_TIMESTAMP&#39;]&#34;, out, re.MULTILINE)
#            assert err == &#39;&#39;


# TODO
# @pytest.mark.unit
# @pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
# def test_main_pos_fields_valid_values(capsys):
#    &#34;&#34;&#34;Test --pos-fields with valid values&#34;&#34;&#34;
#    sys.argv = [&#39;&#39;, &#39;--pos-fields&#39;, &#39;POS_GEO_SEP&#39;, &#39;POS_ALT_MSL&#39;]
#    mt_config.args = sys.argv
#
#    pos_flags = MagicMock(autospec=meshtastic.radioconfig_pb2.PositionFlags)
#
#    with patch(&#39;meshtastic.serial_interface.SerialInterface&#39;) as mo:
#        with patch(&#39;meshtastic.radioconfig_pb2.PositionFlags&#39;, return_value=pos_flags) as mrc:
#
#            mrc.Value.side_effect = [ 4, 2 ]
#
#            main()
#
#            mrc.Value.assert_called()
#            mo.assert_called()
#
#            out, err = capsys.readouterr()
#            assert re.search(r&#39;Connected to radio&#39;, out, re.MULTILINE)
#            assert re.search(r&#39;Setting position fields to 6&#39;, out, re.MULTILINE)
#            assert re.search(r&#39;Set position_flags to 6&#39;, out, re.MULTILINE)
#            assert re.search(r&#39;Writing modified preferences to device&#39;, out, re.MULTILINE)
#            assert err == &#39;&#39;


# TODO
# @pytest.mark.unit
# @pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
# def test_main_get_with_valid_values(capsys):
#    &#34;&#34;&#34;Test --get with valid values (with string, number, boolean)&#34;&#34;&#34;
#    sys.argv = [&#39;&#39;, &#39;--get&#39;, &#39;ls_secs&#39;, &#39;--get&#39;, &#39;wifi_ssid&#39;, &#39;--get&#39;, &#39;fixed_position&#39;]
#    mt_config.args = sys.argv
#
#    with patch(&#39;meshtastic.serial_interface.SerialInterface&#39;) as mo:
#
#        mo().getNode().radioConfig.preferences.wifi_ssid = &#39;foo&#39;
#        mo().getNode().radioConfig.preferences.ls_secs = 300
#        mo().getNode().radioConfig.preferences.fixed_position = False
#
#        main()
#
#        mo.assert_called()
#
#        out, err = capsys.readouterr()
#        assert re.search(r&#39;Connected to radio&#39;, out, re.MULTILINE)
#        assert re.search(r&#39;ls_secs: 300&#39;, out, re.MULTILINE)
#        assert re.search(r&#39;wifi_ssid: foo&#39;, out, re.MULTILINE)
#        assert re.search(r&#39;fixed_position: False&#39;, out, re.MULTILINE)
#        assert err == &#39;&#39;


# TODO
#@pytest.mark.unit
#@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
#def test_main_get_with_valid_values_camel(capsys, caplog):
#    &#34;&#34;&#34;Test --get with valid values (with string, number, boolean)&#34;&#34;&#34;
#    sys.argv = [&#34;&#34;, &#34;--get&#34;, &#34;lsSecs&#34;, &#34;--get&#34;, &#34;wifiSsid&#34;, &#34;--get&#34;, &#34;fixedPosition&#34;]
#    mt_config.args = sys.argv
#    mt_config.camel_case = True
#
#    with caplog.at_level(logging.DEBUG):
#        with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;) as mo:
#            mo().getNode().radioConfig.preferences.wifi_ssid = &#34;foo&#34;
#            mo().getNode().radioConfig.preferences.ls_secs = 300
#            mo().getNode().radioConfig.preferences.fixed_position = False
#
#            main()
#
#            mo.assert_called()
#
#            out, err = capsys.readouterr()
#            assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
#            assert re.search(r&#34;lsSecs: 300&#34;, out, re.MULTILINE)
#            assert re.search(r&#34;wifiSsid: foo&#34;, out, re.MULTILINE)
#            assert re.search(r&#34;fixedPosition: False&#34;, out, re.MULTILINE)
#            assert err == &#34;&#34;


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_get_with_invalid(capsys):
    &#34;&#34;&#34;Test --get with invalid field&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--get&#34;, &#34;foo&#34;]
    mt_config.args = sys.argv

    mocked_user_prefs = MagicMock()
    mocked_user_prefs.DESCRIPTOR.fields_by_name.get.return_value = None

    mocked_node = MagicMock(autospec=Node)
    mocked_node.localConfig = mocked_user_prefs
    mocked_node.moduleConfig = mocked_user_prefs

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;do not have attribute foo&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Choices are...&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_onReceive_empty(caplog, capsys):
    &#34;&#34;&#34;Test onReceive&#34;&#34;&#34;
    args = MagicMock()
    mt_config.args = args
    iface = MagicMock(autospec=SerialInterface)
    packet = {}
    with caplog.at_level(logging.DEBUG):
        onReceive(packet, iface)
    assert re.search(r&#34;in onReceive&#34;, caplog.text, re.MULTILINE)
    out, err = capsys.readouterr()
    assert re.search(
        r&#34;Warning: There is no field &#39;to&#39; in the packet.&#34;, out, re.MULTILINE
    )
    assert err == &#34;&#34;


#    TODO: use this captured position app message (might want/need in the future)
#    packet = {
#            &#39;to&#39;: 4294967295,
#            &#39;decoded&#39;: {
#                &#39;portnum&#39;: &#39;POSITION_APP&#39;,
#                &#39;payload&#39;: &#34;M69\306a&#34;
#                },
#            &#39;id&#39;: 334776976,
#            &#39;hop_limit&#39;: 3
#            }


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_onReceive_with_sendtext(caplog, capsys):
    &#34;&#34;&#34;Test onReceive with sendtext
    The entire point of this test is to make sure the interface.close() call
    is made in onReceive().
    &#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--sendtext&#34;, &#34;hello&#34;]
    mt_config.args = sys.argv

    # Note: &#39;TEXT_MESSAGE_APP&#39; value is 1
    packet = {
        &#34;to&#34;: 4294967295,
        &#34;decoded&#34;: {&#34;portnum&#34;: 1, &#34;payload&#34;: &#34;hello&#34;},
        &#34;id&#34;: 334776977,
        &#34;hop_limit&#34;: 3,
        &#34;want_ack&#34;: True,
    }

    iface = MagicMock(autospec=SerialInterface)
    iface.myInfo.my_node_num = 4294967295

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        with caplog.at_level(logging.DEBUG):
            main()
            onReceive(packet, iface)
        assert re.search(r&#34;in onReceive&#34;, caplog.text, re.MULTILINE)
        mo.assert_called()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Sending text message hello to&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_onReceive_with_text(caplog, capsys):
    &#34;&#34;&#34;Test onReceive with text&#34;&#34;&#34;
    args = MagicMock()
    args.sendtext.return_value = &#34;foo&#34;
    mt_config.args = args

    # Note: &#39;TEXT_MESSAGE_APP&#39; value is 1
    # Note: Some of this is faked below.
    packet = {
        &#34;to&#34;: 4294967295,
        &#34;decoded&#34;: {&#34;portnum&#34;: 1, &#34;payload&#34;: &#34;hello&#34;, &#34;text&#34;: &#34;faked&#34;},
        &#34;id&#34;: 334776977,
        &#34;hop_limit&#34;: 3,
        &#34;want_ack&#34;: True,
        &#34;rxSnr&#34;: 6.0,
        &#34;hopLimit&#34;: 3,
        &#34;raw&#34;: &#34;faked&#34;,
        &#34;fromId&#34;: &#34;!28b5465c&#34;,
        &#34;toId&#34;: &#34;^all&#34;,
    }

    iface = MagicMock(autospec=SerialInterface)
    iface.myInfo.my_node_num = 4294967295

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface):
        with caplog.at_level(logging.DEBUG):
            onReceive(packet, iface)
        assert re.search(r&#34;in onReceive&#34;, caplog.text, re.MULTILINE)
        out, err = capsys.readouterr()
        assert re.search(r&#34;Sending reply&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_onConnection(capsys):
    &#34;&#34;&#34;Test onConnection&#34;&#34;&#34;
    sys.argv = [&#34;&#34;]
    mt_config.args = sys.argv
    iface = MagicMock(autospec=SerialInterface)

    class TempTopic:
        &#34;&#34;&#34;temp class for topic&#34;&#34;&#34;

        def getName(self):
            &#34;&#34;&#34;return the fake name of a topic&#34;&#34;&#34;
            return &#34;foo&#34;

    mytopic = TempTopic()
    onConnection(iface, mytopic)
    out, err = capsys.readouterr()
    assert re.search(r&#34;Connection changed: foo&#34;, out, re.MULTILINE)
    assert err == &#34;&#34;


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_export_config(capsys):
    &#34;&#34;&#34;Test export_config() function directly&#34;&#34;&#34;
    iface = MagicMock(autospec=SerialInterface)
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        mo.getLongName.return_value = &#34;foo&#34;
        mo.getShortName.return_value = &#34;oof&#34;
        mo.localNode.getURL.return_value = &#34;bar&#34;
        mo.getMyNodeInfo().get.return_value = {
            &#34;latitudeI&#34;: 1100000000,
            &#34;longitudeI&#34;: 1200000000,
            &#34;altitude&#34;: 100,
            &#34;batteryLevel&#34;: 34,
            &#34;latitude&#34;: 110.0,
            &#34;longitude&#34;: 120.0,
        }
        mo.localNode.radioConfig.preferences = &#34;&#34;&#34;phone_timeout_secs: 900
ls_secs: 300
position_broadcast_smart: true
fixed_position: true
position_flags: 35&#34;&#34;&#34;
        export_config(mo)
    out, err = capsys.readouterr()

    # ensure we do not output this line
    assert not re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)

    assert re.search(r&#34;owner: foo&#34;, out, re.MULTILINE)
    assert re.search(r&#34;owner_short: oof&#34;, out, re.MULTILINE)
    assert re.search(r&#34;channel_url: bar&#34;, out, re.MULTILINE)
    assert re.search(r&#34;location:&#34;, out, re.MULTILINE)
    assert re.search(r&#34;lat: 110.0&#34;, out, re.MULTILINE)
    assert re.search(r&#34;lon: 120.0&#34;, out, re.MULTILINE)
    assert re.search(r&#34;alt: 100&#34;, out, re.MULTILINE)
    # TODO: rework above config to test the following
    #assert re.search(r&#34;user_prefs:&#34;, out, re.MULTILINE)
    #assert re.search(r&#34;phone_timeout_secs: 900&#34;, out, re.MULTILINE)
    #assert re.search(r&#34;ls_secs: 300&#34;, out, re.MULTILINE)
    #assert re.search(r&#34;position_broadcast_smart: &#39;true&#39;&#34;, out, re.MULTILINE)
    #assert re.search(r&#34;fixed_position: &#39;true&#39;&#34;, out, re.MULTILINE)
    #assert re.search(r&#34;position_flags: 35&#34;, out, re.MULTILINE)
    assert err == &#34;&#34;


# TODO
# recursion depth exceeded error
#@pytest.mark.unit
#@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
#def test_main_export_config_use_camel(capsys):
#    &#34;&#34;&#34;Test export_config() function directly&#34;&#34;&#34;
#    mt_config.camel_case = True
#    iface = MagicMock(autospec=SerialInterface)
#    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
#        mo.getLongName.return_value = &#34;foo&#34;
#        mo.localNode.getURL.return_value = &#34;bar&#34;
#        mo.getMyNodeInfo().get.return_value = {
#            &#34;latitudeI&#34;: 1100000000,
#            &#34;longitudeI&#34;: 1200000000,
#            &#34;altitude&#34;: 100,
#            &#34;batteryLevel&#34;: 34,
#            &#34;latitude&#34;: 110.0,
#            &#34;longitude&#34;: 120.0,
#        }
#        mo.localNode.radioConfig.preferences = &#34;&#34;&#34;phone_timeout_secs: 900
#ls_secs: 300
#position_broadcast_smart: true
#fixed_position: true
#position_flags: 35&#34;&#34;&#34;
#        export_config(mo)
#    out, err = capsys.readouterr()
#
#    # ensure we do not output this line
#    assert not re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
#
#    assert re.search(r&#34;owner: foo&#34;, out, re.MULTILINE)
#    assert re.search(r&#34;channelUrl: bar&#34;, out, re.MULTILINE)
#    assert re.search(r&#34;location:&#34;, out, re.MULTILINE)
#    assert re.search(r&#34;lat: 110.0&#34;, out, re.MULTILINE)
#    assert re.search(r&#34;lon: 120.0&#34;, out, re.MULTILINE)
#    assert re.search(r&#34;alt: 100&#34;, out, re.MULTILINE)
#    assert re.search(r&#34;userPrefs:&#34;, out, re.MULTILINE)
#    assert re.search(r&#34;phoneTimeoutSecs: 900&#34;, out, re.MULTILINE)
#    assert re.search(r&#34;lsSecs: 300&#34;, out, re.MULTILINE)
#    # TODO: should True be capitalized here?
#    assert re.search(r&#34;positionBroadcastSmart: &#39;True&#39;&#34;, out, re.MULTILINE)
#    assert re.search(r&#34;fixedPosition: &#39;True&#39;&#34;, out, re.MULTILINE)
#    assert re.search(r&#34;positionFlags: 35&#34;, out, re.MULTILINE)
#    assert err == &#34;&#34;


# TODO
# maximum recursion depth error
#@pytest.mark.unit
#@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
#def test_main_export_config_called_from_main(capsys):
#    &#34;&#34;&#34;Test --export-config&#34;&#34;&#34;
#    sys.argv = [&#34;&#34;, &#34;--export-config&#34;]
#    mt_config.args = sys.argv
#
#    iface = MagicMock(autospec=SerialInterface)
#    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
#        main()
#        out, err = capsys.readouterr()
#        assert not re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
#        assert re.search(r&#34;# start of Meshtastic configure yaml&#34;, out, re.MULTILINE)
#        assert err == &#34;&#34;
#        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_gpio_rd_no_gpio_channel(capsys):
    &#34;&#34;&#34;Test --gpio_rd with no named gpio channel&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--gpio-rd&#34;, &#34;0x10&#34;, &#34;--dest&#34;, &#34;!foo&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)
    iface.localNode.getChannelByName.return_value = None
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface):
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;Warning: No channel named&#34;, out)
        assert err == &#34;&#34;


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_gpio_rd_no_dest(capsys):
    &#34;&#34;&#34;Test --gpio_rd with a named gpio channel but no dest was specified&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--gpio-rd&#34;, &#34;0x2000&#34;]
    mt_config.args = sys.argv

    channel = Channel(index=2, role=2)
    channel.settings.psk = b&#34;\x8a\x94y\x0e\xc6\xc9\x1e5\x91\x12@\xa60\xa8\xb43\x87\x00\xf2K\x0e\xe7\x7fAz\xcd\xf5\xb0\x900\xa84&#34;
    channel.settings.name = &#34;gpio&#34;

    iface = MagicMock(autospec=SerialInterface)
    iface.localNode.getChannelByName.return_value = channel
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface):
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;Warning: Must use a destination node ID&#34;, out)
        assert err == &#34;&#34;


# TODO
# @pytest.mark.unit
# @pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
# @patch(&#39;time.sleep&#39;)
# def test_main_gpio_rd(caplog, capsys):
#    &#34;&#34;&#34;Test --gpio_rd with a named gpio channel&#34;&#34;&#34;
#    # Note: On the Heltec v2.1, there is a GPIO pin GPIO 13 that does not have a
#    # red arrow (meaning ok to use for our purposes)
#    # See https://resource.heltec.cn/download/WiFi_LoRa_32/WIFI_LoRa_32_V2.pdf
#    # To find out the mask for GPIO 13, let us assign n as 13.
#    # 1. Find the 2^n or 2^13 (8192)
#    # 2. Convert 8192 decimal to hex (0x2000)
#    # You can use python:
#    # &gt;&gt;&gt; print(hex(2**13))
#    # 0x2000
#    sys.argv = [&#39;&#39;, &#39;--gpio-rd&#39;, &#39;0x1000&#39;, &#39;--dest&#39;, &#39;!1234&#39;]
#    mt_config.args = sys.argv
#
#    channel = Channel(index=1, role=1)
#    channel.settings.modem_config = 3
#    channel.settings.psk = b&#39;\x01&#39;
#
#    packet = {
#
#            &#39;from&#39;: 682968668,
#            &#39;to&#39;: 682968612,
#            &#39;channel&#39;: 1,
#            &#39;decoded&#39;: {
#                &#39;portnum&#39;: &#39;REMOTE_HARDWARE_APP&#39;,
#                &#39;payload&#39;: b&#39;\x08\x05\x18\x80 &#39;,
#                &#39;requestId&#39;: 1629980484,
#                &#39;remotehw&#39;: {
#                    &#39;typ&#39;: &#39;READ_GPIOS_REPLY&#39;,
#                    &#39;gpioValue&#39;: &#39;4096&#39;,
#                    &#39;raw&#39;: &#39;faked&#39;,
#                    &#39;id&#39;: 1693085229,
#                    &#39;rxTime&#39;: 1640294262,
#                    &#39;rxSnr&#39;: 4.75,
#                    &#39;hopLimit&#39;: 3,
#                    &#39;wantAck&#39;: True,
#                    }
#                }
#            }
#
#    iface = MagicMock(autospec=SerialInterface)
#    iface.localNode.getChannelByName.return_value = channel
#    with patch(&#39;meshtastic.serial_interface.SerialInterface&#39;, return_value=iface) as mo:
#        with caplog.at_level(logging.DEBUG):
#            main()
#            onGPIOreceive(packet, mo)
#    out, err = capsys.readouterr()
#    assert re.search(r&#39;Connected to radio&#39;, out, re.MULTILINE)
#    assert re.search(r&#39;Reading GPIO mask 0x1000 &#39;, out, re.MULTILINE)
#    assert re.search(r&#39;Received RemoteHardware typ=READ_GPIOS_REPLY, gpio_value=4096&#39;, out, re.MULTILINE)
#    assert err == &#39;&#39;


# TODO
# @pytest.mark.unit
# @pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
# @patch(&#39;time.sleep&#39;)
# def test_main_gpio_rd_with_no_gpioMask(caplog, capsys):
#    &#34;&#34;&#34;Test --gpio_rd with a named gpio channel&#34;&#34;&#34;
#    sys.argv = [&#39;&#39;, &#39;--gpio-rd&#39;, &#39;0x1000&#39;, &#39;--dest&#39;, &#39;!1234&#39;]
#    mt_config.args = sys.argv
#
#    channel = Channel(index=1, role=1)
#    channel.settings.modem_config = 3
#    channel.settings.psk = b&#39;\x01&#39;
#
#    # Note: Intentionally do not have gpioValue in response as that is the
#    # default value
#    packet = {
#            &#39;from&#39;: 682968668,
#            &#39;to&#39;: 682968612,
#            &#39;channel&#39;: 1,
#            &#39;decoded&#39;: {
#                &#39;portnum&#39;: &#39;REMOTE_HARDWARE_APP&#39;,
#                &#39;payload&#39;: b&#39;\x08\x05\x18\x80 &#39;,
#                &#39;requestId&#39;: 1629980484,
#                &#39;remotehw&#39;: {
#                    &#39;typ&#39;: &#39;READ_GPIOS_REPLY&#39;,
#                    &#39;raw&#39;: &#39;faked&#39;,
#                    &#39;id&#39;: 1693085229,
#                    &#39;rxTime&#39;: 1640294262,
#                    &#39;rxSnr&#39;: 4.75,
#                    &#39;hopLimit&#39;: 3,
#                    &#39;wantAck&#39;: True,
#                    }
#                }
#            }
#
#    iface = MagicMock(autospec=SerialInterface)
#    iface.localNode.getChannelByName.return_value = channel
#    with patch(&#39;meshtastic.serial_interface.SerialInterface&#39;, return_value=iface) as mo:
#        with caplog.at_level(logging.DEBUG):
#            main()
#            onGPIOreceive(packet, mo)
#    out, err = capsys.readouterr()
#    assert re.search(r&#39;Connected to radio&#39;, out, re.MULTILINE)
#    assert re.search(r&#39;Reading GPIO mask 0x1000 &#39;, out, re.MULTILINE)
#    assert re.search(r&#39;Received RemoteHardware typ=READ_GPIOS_REPLY, gpio_value=0&#39;, out, re.MULTILINE)
#    assert err == &#39;&#39;


# TODO
# @pytest.mark.unit
# @pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
# def test_main_gpio_watch(caplog, capsys):
#    &#34;&#34;&#34;Test --gpio_watch with a named gpio channel&#34;&#34;&#34;
#    sys.argv = [&#39;&#39;, &#39;--gpio-watch&#39;, &#39;0x1000&#39;, &#39;--dest&#39;, &#39;!1234&#39;]
#    mt_config.args = sys.argv
#
#    def my_sleep(amount):
#        print(f&#39;{amount}&#39;)
#        sys.exit(3)
#
#    channel = Channel(index=1, role=1)
#    channel.settings.modem_config = 3
#    channel.settings.psk = b&#39;\x01&#39;
#
#    packet = {
#
#            &#39;from&#39;: 682968668,
#            &#39;to&#39;: 682968612,
#            &#39;channel&#39;: 1,
#            &#39;decoded&#39;: {
#                &#39;portnum&#39;: &#39;REMOTE_HARDWARE_APP&#39;,
#                &#39;payload&#39;: b&#39;\x08\x05\x18\x80 &#39;,
#                &#39;requestId&#39;: 1629980484,
#                &#39;remotehw&#39;: {
#                    &#39;typ&#39;: &#39;READ_GPIOS_REPLY&#39;,
#                    &#39;gpioValue&#39;: &#39;4096&#39;,
#                    &#39;raw&#39;: &#39;faked&#39;,
#                    &#39;id&#39;: 1693085229,
#                    &#39;rxTime&#39;: 1640294262,
#                    &#39;rxSnr&#39;: 4.75,
#                    &#39;hopLimit&#39;: 3,
#                    &#39;wantAck&#39;: True,
#                    }
#                }
#            }
#
#    with patch(&#39;time.sleep&#39;, side_effect=my_sleep):
#        with pytest.raises(SystemExit) as pytest_wrapped_e:
#            iface = MagicMock(autospec=SerialInterface)
#            iface.localNode.getChannelByName.return_value = channel
#            with patch(&#39;meshtastic.serial_interface.SerialInterface&#39;, return_value=iface) as mo:
#                with caplog.at_level(logging.DEBUG):
#                    main()
#                    onGPIOreceive(packet, mo)
#        assert pytest_wrapped_e.type == SystemExit
#        assert pytest_wrapped_e.value.code == 3
#        out, err = capsys.readouterr()
#        assert re.search(r&#39;Connected to radio&#39;, out, re.MULTILINE)
#        assert re.search(r&#39;Watching GPIO mask 0x1000 &#39;, out, re.MULTILINE)
#        assert err == &#39;&#39;


# TODO
# @pytest.mark.unit
# @pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
# def test_main_gpio_wrb(caplog, capsys):
#    &#34;&#34;&#34;Test --gpio_wrb with a named gpio channel&#34;&#34;&#34;
#    sys.argv = [&#39;&#39;, &#39;--gpio-wrb&#39;, &#39;4&#39;, &#39;1&#39;, &#39;--dest&#39;, &#39;!1234&#39;]
#    mt_config.args = sys.argv
#
#    channel = Channel(index=1, role=1)
#    channel.settings.modem_config = 3
#    channel.settings.psk = b&#39;\x01&#39;
#
#    packet = {
#
#            &#39;from&#39;: 682968668,
#            &#39;to&#39;: 682968612,
#            &#39;channel&#39;: 1,
#            &#39;decoded&#39;: {
#                &#39;portnum&#39;: &#39;REMOTE_HARDWARE_APP&#39;,
#                &#39;payload&#39;: b&#39;\x08\x05\x18\x80 &#39;,
#                &#39;requestId&#39;: 1629980484,
#                &#39;remotehw&#39;: {
#                    &#39;typ&#39;: &#39;READ_GPIOS_REPLY&#39;,
#                    &#39;gpioValue&#39;: &#39;16&#39;,
#                    &#39;raw&#39;: &#39;faked&#39;,
#                    &#39;id&#39;: 1693085229,
#                    &#39;rxTime&#39;: 1640294262,
#                    &#39;rxSnr&#39;: 4.75,
#                    &#39;hopLimit&#39;: 3,
#                    &#39;wantAck&#39;: True,
#                    }
#                }
#            }
#
#
#    iface = MagicMock(autospec=SerialInterface)
#    iface.localNode.getChannelByName.return_value = channel
#    with patch(&#39;meshtastic.serial_interface.SerialInterface&#39;, return_value=iface) as mo:
#        with caplog.at_level(logging.DEBUG):
#            main()
#            onGPIOreceive(packet, mo)
#    out, err = capsys.readouterr()
#    assert re.search(r&#39;Connected to radio&#39;, out, re.MULTILINE)
#    assert re.search(r&#39;Writing GPIO mask 0x10 with value 0x10 to !1234&#39;, out, re.MULTILINE)
#    assert re.search(r&#39;Received RemoteHardware typ=READ_GPIOS_REPLY, gpio_value=16 value=0&#39;, out, re.MULTILINE)
#    assert err == &#39;&#39;


# TODO
# need to restructure these for nested configs
#@pytest.mark.unit
#@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
#def test_main_getPref_valid_field(capsys):
#    &#34;&#34;&#34;Test getPref() with a valid field&#34;&#34;&#34;
#    prefs = MagicMock()
#    prefs.DESCRIPTOR.fields_by_name.get.return_value = &#34;ls_secs&#34;
#    prefs.wifi_ssid = &#34;foo&#34;
#    prefs.ls_secs = 300
#    prefs.fixed_position = False
#
#    getPref(prefs, &#34;ls_secs&#34;)
#    out, err = capsys.readouterr()
#    assert re.search(r&#34;ls_secs: 300&#34;, out, re.MULTILINE)
#    assert err == &#34;&#34;
#
#
#@pytest.mark.unit
#@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
#def test_main_getPref_valid_field_camel(capsys):
#    &#34;&#34;&#34;Test getPref() with a valid field&#34;&#34;&#34;
#    mt_config.camel_case = True
#    prefs = MagicMock()
#    prefs.DESCRIPTOR.fields_by_name.get.return_value = &#34;ls_secs&#34;
#    prefs.wifi_ssid = &#34;foo&#34;
#    prefs.ls_secs = 300
#    prefs.fixed_position = False
#
#    getPref(prefs, &#34;ls_secs&#34;)
#    out, err = capsys.readouterr()
#    assert re.search(r&#34;lsSecs: 300&#34;, out, re.MULTILINE)
#    assert err == &#34;&#34;
#
#
#@pytest.mark.unit
#@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
#def test_main_getPref_valid_field_string(capsys):
#    &#34;&#34;&#34;Test getPref() with a valid field and value as a string&#34;&#34;&#34;
#    prefs = MagicMock()
#    prefs.DESCRIPTOR.fields_by_name.get.return_value = &#34;wifi_ssid&#34;
#    prefs.wifi_ssid = &#34;foo&#34;
#    prefs.ls_secs = 300
#    prefs.fixed_position = False
#
#    getPref(prefs, &#34;wifi_ssid&#34;)
#    out, err = capsys.readouterr()
#    assert re.search(r&#34;wifi_ssid: foo&#34;, out, re.MULTILINE)
#    assert err == &#34;&#34;
#
#
#@pytest.mark.unit
#@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
#def test_main_getPref_valid_field_string_camel(capsys):
#    &#34;&#34;&#34;Test getPref() with a valid field and value as a string&#34;&#34;&#34;
#    mt_config.camel_case = True
#    prefs = MagicMock()
#    prefs.DESCRIPTOR.fields_by_name.get.return_value = &#34;wifi_ssid&#34;
#    prefs.wifi_ssid = &#34;foo&#34;
#    prefs.ls_secs = 300
#    prefs.fixed_position = False
#
#    getPref(prefs, &#34;wifi_ssid&#34;)
#    out, err = capsys.readouterr()
#    assert re.search(r&#34;wifiSsid: foo&#34;, out, re.MULTILINE)
#    assert err == &#34;&#34;
#
#
#@pytest.mark.unit
#@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
#def test_main_getPref_valid_field_bool(capsys):
#    &#34;&#34;&#34;Test getPref() with a valid field and value as a bool&#34;&#34;&#34;
#    prefs = MagicMock()
#    prefs.DESCRIPTOR.fields_by_name.get.return_value = &#34;fixed_position&#34;
#    prefs.wifi_ssid = &#34;foo&#34;
#    prefs.ls_secs = 300
#    prefs.fixed_position = False
#
#    getPref(prefs, &#34;fixed_position&#34;)
#    out, err = capsys.readouterr()
#    assert re.search(r&#34;fixed_position: False&#34;, out, re.MULTILINE)
#    assert err == &#34;&#34;
#
#
#@pytest.mark.unit
#@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
#def test_main_getPref_valid_field_bool_camel(capsys):
#    &#34;&#34;&#34;Test getPref() with a valid field and value as a bool&#34;&#34;&#34;
#    mt_config.camel_case = True
#    prefs = MagicMock()
#    prefs.DESCRIPTOR.fields_by_name.get.return_value = &#34;fixed_position&#34;
#    prefs.wifi_ssid = &#34;foo&#34;
#    prefs.ls_secs = 300
#    prefs.fixed_position = False
#
#    getPref(prefs, &#34;fixed_position&#34;)
#    out, err = capsys.readouterr()
#    assert re.search(r&#34;fixedPosition: False&#34;, out, re.MULTILINE)
#    assert err == &#34;&#34;
#
#
#@pytest.mark.unit
#@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
#def test_main_getPref_invalid_field(capsys):
#    &#34;&#34;&#34;Test getPref() with an invalid field&#34;&#34;&#34;
#
#    class Field:
#        &#34;&#34;&#34;Simple class for testing.&#34;&#34;&#34;
#
#        def __init__(self, name):
#            &#34;&#34;&#34;constructor&#34;&#34;&#34;
#            self.name = name
#
#    prefs = MagicMock()
#    prefs.DESCRIPTOR.fields_by_name.get.return_value = None
#
#    # Note: This is a subset of the real fields
#    ls_secs_field = Field(&#34;ls_secs&#34;)
#    is_router = Field(&#34;is_router&#34;)
#    fixed_position = Field(&#34;fixed_position&#34;)
#
#    fields = [ls_secs_field, is_router, fixed_position]
#    prefs.DESCRIPTOR.fields = fields
#
#    getPref(prefs, &#34;foo&#34;)
#
#    out, err = capsys.readouterr()
#    assert re.search(r&#34;does not have an attribute called foo&#34;, out, re.MULTILINE)
#    # ensure they are sorted
#    assert re.search(r&#34;fixed_position\s+is_router\s+ls_secs&#34;, out, re.MULTILINE)
#    assert err == &#34;&#34;
#
#
#@pytest.mark.unit
#@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
#def test_main_getPref_invalid_field_camel(capsys):
#    &#34;&#34;&#34;Test getPref() with an invalid field&#34;&#34;&#34;
#    mt_config.camel_case = True
#
#    class Field:
#        &#34;&#34;&#34;Simple class for testing.&#34;&#34;&#34;
#
#        def __init__(self, name):
#            &#34;&#34;&#34;constructor&#34;&#34;&#34;
#            self.name = name
#
#    prefs = MagicMock()
#    prefs.DESCRIPTOR.fields_by_name.get.return_value = None
#
#    # Note: This is a subset of the real fields
#    ls_secs_field = Field(&#34;ls_secs&#34;)
#    is_router = Field(&#34;is_router&#34;)
#    fixed_position = Field(&#34;fixed_position&#34;)
#
#    fields = [ls_secs_field, is_router, fixed_position]
#    prefs.DESCRIPTOR.fields = fields
#
#    getPref(prefs, &#34;foo&#34;)
#
#    out, err = capsys.readouterr()
#    assert re.search(r&#34;does not have an attribute called foo&#34;, out, re.MULTILINE)
#    # ensure they are sorted
#    assert re.search(r&#34;fixedPosition\s+isRouter\s+lsSecs&#34;, out, re.MULTILINE)
#    assert err == &#34;&#34;
#
#
#@pytest.mark.unit
#@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
#def test_main_setPref_valid_field_int_as_string(capsys):
#    &#34;&#34;&#34;Test setPref() with a valid field&#34;&#34;&#34;
#
#    class Field:
#        &#34;&#34;&#34;Simple class for testing.&#34;&#34;&#34;
#
#        def __init__(self, name, enum_type):
#            &#34;&#34;&#34;constructor&#34;&#34;&#34;
#            self.name = name
#            self.enum_type = enum_type
#
#    ls_secs_field = Field(&#34;ls_secs&#34;, &#34;int&#34;)
#    prefs = MagicMock()
#    prefs.DESCRIPTOR.fields_by_name.get.return_value = ls_secs_field
#
#    setPref(prefs, &#34;ls_secs&#34;, &#34;300&#34;)
#    out, err = capsys.readouterr()
#    assert re.search(r&#34;Set ls_secs to 300&#34;, out, re.MULTILINE)
#    assert err == &#34;&#34;


# TODO
# @pytest.mark.unit
# @pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
# def test_main_setPref_valid_field_invalid_enum(capsys, caplog):
#    &#34;&#34;&#34;Test setPref() with a valid field but invalid enum value&#34;&#34;&#34;
#
#    radioConfig = RadioConfig()
#    prefs = radioConfig.preferences
#
#    with caplog.at_level(logging.DEBUG):
#        setPref(prefs, &#39;charge_current&#39;, &#39;foo&#39;)
#        out, err = capsys.readouterr()
#        assert re.search(r&#39;charge_current does not have an enum called foo&#39;, out, re.MULTILINE)
#        assert re.search(r&#39;Choices in sorted order are&#39;, out, re.MULTILINE)
#        assert re.search(r&#39;MA100&#39;, out, re.MULTILINE)
#        assert re.search(r&#39;MA280&#39;, out, re.MULTILINE)
#        assert err == &#39;&#39;


# TODO
# @pytest.mark.unit
# @pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
# def test_main_setPref_valid_field_invalid_enum_where_enums_are_camel_cased_values(capsys, caplog):
#    &#34;&#34;&#34;Test setPref() with a valid field but invalid enum value&#34;&#34;&#34;
#
#    radioConfig = RadioConfig()
#    prefs = radioConfig.preferences
#
#    with caplog.at_level(logging.DEBUG):
#        setPref(prefs, &#39;region&#39;, &#39;foo&#39;)
#        out, err = capsys.readouterr()
#        assert re.search(r&#39;region does not have an enum called foo&#39;, out, re.MULTILINE)
#        assert re.search(r&#39;Choices in sorted order are&#39;, out, re.MULTILINE)
#        assert re.search(r&#39;ANZ&#39;, out, re.MULTILINE)
#        assert re.search(r&#39;CN&#39;, out, re.MULTILINE)
#        assert err == &#39;&#39;


# TODO
# @pytest.mark.unit
# @pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
# def test_main_setPref_valid_field_invalid_enum_camel(capsys, caplog):
#    &#34;&#34;&#34;Test setPref() with a valid field but invalid enum value&#34;&#34;&#34;
#    mt_config.camel_case = True
#
#    radioConfig = RadioConfig()
#    prefs = radioConfig.preferences
#
#    with caplog.at_level(logging.DEBUG):
#        setPref(prefs, &#39;charge_current&#39;, &#39;foo&#39;)
#        out, err = capsys.readouterr()
#        assert re.search(r&#39;chargeCurrent does not have an enum called foo&#39;, out, re.MULTILINE)
#        assert err == &#39;&#39;


# TODO
# @pytest.mark.unit
# @pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
# def test_main_setPref_valid_field_valid_enum(capsys, caplog):
#    &#34;&#34;&#34;Test setPref() with a valid field and valid enum value&#34;&#34;&#34;
#
#    # charge_current
#    # some valid values:   MA100 MA1000 MA1080
#
#    radioConfig = RadioConfig()
#    prefs = radioConfig.preferences
#
#    with caplog.at_level(logging.DEBUG):
#        setPref(prefs, &#39;charge_current&#39;, &#39;MA100&#39;)
#        out, err = capsys.readouterr()
#        assert re.search(r&#39;Set charge_current to MA100&#39;, out, re.MULTILINE)
#        assert err == &#39;&#39;


# TODO
# @pytest.mark.unit
# @pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
# def test_main_setPref_valid_field_valid_enum_camel(capsys, caplog):
#    &#34;&#34;&#34;Test setPref() with a valid field and valid enum value&#34;&#34;&#34;
#    mt_config.camel_case = True
#
#    # charge_current
#    # some valid values:   MA100 MA1000 MA1080
#
#    radioConfig = RadioConfig()
#    prefs = radioConfig.preferences
#
#    with caplog.at_level(logging.DEBUG):
#        setPref(prefs, &#39;charge_current&#39;, &#39;MA100&#39;)
#        out, err = capsys.readouterr()
#        assert re.search(r&#39;Set chargeCurrent to MA100&#39;, out, re.MULTILINE)
#        assert err == &#39;&#39;

# TODO
# need to update for nested configs
#@pytest.mark.unit
#@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
#def test_main_setPref_invalid_field(capsys):
#    &#34;&#34;&#34;Test setPref() with a invalid field&#34;&#34;&#34;
#
#    class Field:
#        &#34;&#34;&#34;Simple class for testing.&#34;&#34;&#34;
#
#        def __init__(self, name):
#            &#34;&#34;&#34;constructor&#34;&#34;&#34;
#            self.name = name
#
#    prefs = MagicMock()
#    prefs.DESCRIPTOR.fields_by_name.get.return_value = None
#
#    # Note: This is a subset of the real fields
#    ls_secs_field = Field(&#34;ls_secs&#34;)
#    is_router = Field(&#34;is_router&#34;)
#    fixed_position = Field(&#34;fixed_position&#34;)
#
#    fields = [ls_secs_field, is_router, fixed_position]
#    prefs.DESCRIPTOR.fields = fields
#
#    setPref(prefs, &#34;foo&#34;, &#34;300&#34;)
#    out, err = capsys.readouterr()
#    assert re.search(r&#34;does not have an attribute called foo&#34;, out, re.MULTILINE)
#    # ensure they are sorted
#    assert re.search(r&#34;fixed_position\s+is_router\s+ls_secs&#34;, out, re.MULTILINE)
#    assert err == &#34;&#34;
#
#
#@pytest.mark.unit
#@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
#def test_main_setPref_invalid_field_camel(capsys):
#    &#34;&#34;&#34;Test setPref() with a invalid field&#34;&#34;&#34;
#    mt_config.camel_case = True
#
#    class Field:
#        &#34;&#34;&#34;Simple class for testing.&#34;&#34;&#34;
#
#        def __init__(self, name):
#            &#34;&#34;&#34;constructor&#34;&#34;&#34;
#            self.name = name
#
#    prefs = MagicMock()
#    prefs.DESCRIPTOR.fields_by_name.get.return_value = None
#
#    # Note: This is a subset of the real fields
#    ls_secs_field = Field(&#34;ls_secs&#34;)
#    is_router = Field(&#34;is_router&#34;)
#    fixed_position = Field(&#34;fixed_position&#34;)
#
#    fields = [ls_secs_field, is_router, fixed_position]
#    prefs.DESCRIPTOR.fields = fields
#
#    setPref(prefs, &#34;foo&#34;, &#34;300&#34;)
#    out, err = capsys.readouterr()
#    assert re.search(r&#34;does not have an attribute called foo&#34;, out, re.MULTILINE)
#    # ensure they are sorted
#    assert re.search(r&#34;fixedPosition\s+isRouter\s+lsSecs&#34;, out, re.MULTILINE)
#    assert err == &#34;&#34;
#
#
#@pytest.mark.unit
#@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
#def test_main_setPref_ignore_incoming_123(capsys):
#    &#34;&#34;&#34;Test setPref() with ignore_incoming&#34;&#34;&#34;
#
#    class Field:
#        &#34;&#34;&#34;Simple class for testing.&#34;&#34;&#34;
#
#        def __init__(self, name, enum_type):
#            &#34;&#34;&#34;constructor&#34;&#34;&#34;
#            self.name = name
#            self.enum_type = enum_type
#
#    ignore_incoming_field = Field(&#34;ignore_incoming&#34;, &#34;list&#34;)
#    prefs = MagicMock()
#    prefs.DESCRIPTOR.fields_by_name.get.return_value = ignore_incoming_field
#
#    setPref(prefs, &#34;ignore_incoming&#34;, &#34;123&#34;)
#    out, err = capsys.readouterr()
#    assert re.search(r&#34;Adding &#39;123&#39; to the ignore_incoming list&#34;, out, re.MULTILINE)
#    assert re.search(r&#34;Set ignore_incoming to 123&#34;, out, re.MULTILINE)
#    assert err == &#34;&#34;
#
#
#@pytest.mark.unit
#@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
#def test_main_setPref_ignore_incoming_0(capsys):
#    &#34;&#34;&#34;Test setPref() with ignore_incoming&#34;&#34;&#34;
#
#    class Field:
#        &#34;&#34;&#34;Simple class for testing.&#34;&#34;&#34;
#
#        def __init__(self, name, enum_type):
#            &#34;&#34;&#34;constructor&#34;&#34;&#34;
#            self.name = name
#            self.enum_type = enum_type
#
#    ignore_incoming_field = Field(&#34;ignore_incoming&#34;, &#34;list&#34;)
#    prefs = MagicMock()
#    prefs.DESCRIPTOR.fields_by_name.get.return_value = ignore_incoming_field
#
#    setPref(prefs, &#34;ignore_incoming&#34;, &#34;0&#34;)
#    out, err = capsys.readouterr()
#    assert re.search(r&#34;Clearing ignore_incoming list&#34;, out, re.MULTILINE)
#    assert re.search(r&#34;Set ignore_incoming to 0&#34;, out, re.MULTILINE)
#    assert err == &#34;&#34;


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_set_psk_no_ch_index(capsys):
    &#34;&#34;&#34;Test --ch-set psk&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-set&#34;, &#34;psk&#34;, &#34;foo&#34;, &#34;--host&#34;, &#34;meshtastic.local&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=TCPInterface)
    with patch(&#34;meshtastic.tcp_interface.TCPInterface&#34;, return_value=iface) as mo:
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Warning: Need to specify &#39;--ch-index&#39;&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_set_psk_with_ch_index(capsys):
    &#34;&#34;&#34;Test --ch-set psk&#34;&#34;&#34;
    sys.argv = [
        &#34;&#34;,
        &#34;--ch-set&#34;,
        &#34;psk&#34;,
        &#34;foo&#34;,
        &#34;--host&#34;,
        &#34;meshtastic.local&#34;,
        &#34;--ch-index&#34;,
        &#34;0&#34;,
    ]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=TCPInterface)
    with patch(&#34;meshtastic.tcp_interface.TCPInterface&#34;, return_value=iface) as mo:
        main()
    out, err = capsys.readouterr()
    assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
    assert re.search(r&#34;Writing modified channels to device&#34;, out, re.MULTILINE)
    assert err == &#34;&#34;
    mo.assert_called()


# TODO
# doesn&#39;t work properly with nested/module config stuff
#@pytest.mark.unit
#@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
#def test_main_ch_set_name_with_ch_index(capsys):
#    &#34;&#34;&#34;Test --ch-set setting other than psk&#34;&#34;&#34;
#    sys.argv = [
#        &#34;&#34;,
#        &#34;--ch-set&#34;,
#        &#34;name&#34;,
#        &#34;foo&#34;,
#        &#34;--host&#34;,
#        &#34;meshtastic.local&#34;,
#        &#34;--ch-index&#34;,
#        &#34;0&#34;,
#    ]
#    mt_config.args = sys.argv
#
#    iface = MagicMock(autospec=TCPInterface)
#    with patch(&#34;meshtastic.tcp_interface.TCPInterface&#34;, return_value=iface) as mo:
#        main()
#    out, err = capsys.readouterr()
#    assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
#    assert re.search(r&#34;Set name to foo&#34;, out, re.MULTILINE)
#    assert re.search(r&#34;Writing modified channels to device&#34;, out, re.MULTILINE)
#    assert err == &#34;&#34;
#    mo.assert_called()


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_onNode(capsys):
    &#34;&#34;&#34;Test onNode&#34;&#34;&#34;
    onNode(&#34;foo&#34;)
    out, err = capsys.readouterr()
    assert re.search(r&#34;Node changed&#34;, out, re.MULTILINE)
    assert err == &#34;&#34;


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_tunnel_no_args(capsys):
    &#34;&#34;&#34;Test tunnel no arguments&#34;&#34;&#34;
    sys.argv = [&#34;&#34;]
    mt_config.args = sys.argv
    with pytest.raises(SystemExit) as pytest_wrapped_e:
        tunnelMain()
    assert pytest_wrapped_e.type == SystemExit
    assert pytest_wrapped_e.value.code == 1
    _, err = capsys.readouterr()
    assert re.search(r&#34;usage: &#34;, err, re.MULTILINE)


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[])
@patch(&#34;platform.system&#34;)
def test_tunnel_tunnel_arg_with_no_devices(mock_platform_system, caplog, capsys):
    &#34;&#34;&#34;Test tunnel with tunnel arg (act like we are on a linux system)&#34;&#34;&#34;
    a_mock = MagicMock()
    a_mock.return_value = &#34;Linux&#34;
    mock_platform_system.side_effect = a_mock
    sys.argv = [&#34;&#34;, &#34;--tunnel&#34;]
    mt_config.args = sys.argv
    print(f&#34;platform.system():{platform.system()}&#34;)
    with caplog.at_level(logging.DEBUG):
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            tunnelMain()
        mock_platform_system.assert_called()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;No.*Meshtastic.*device.*detected&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[])
@patch(&#34;platform.system&#34;)
def test_tunnel_subnet_arg_with_no_devices(mock_platform_system, caplog, capsys):
    &#34;&#34;&#34;Test tunnel with subnet arg (act like we are on a linux system)&#34;&#34;&#34;
    a_mock = MagicMock()
    a_mock.return_value = &#34;Linux&#34;
    mock_platform_system.side_effect = a_mock
    sys.argv = [&#34;&#34;, &#34;--subnet&#34;, &#34;foo&#34;]
    mt_config.args = sys.argv
    print(f&#34;platform.system():{platform.system()}&#34;)
    with caplog.at_level(logging.DEBUG):
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            tunnelMain()
        mock_platform_system.assert_called()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;No.*Meshtastic.*device.*detected&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;


@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;platform.system&#34;)
@patch(&#34;termios.tcsetattr&#34;)
@patch(&#34;termios.tcgetattr&#34;)
@patch(&#34;builtins.open&#34;, new_callable=mock_open, read_data=&#34;data&#34;)
@patch(&#34;serial.Serial&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[&#34;/dev/ttyUSBfake&#34;])
def test_tunnel_tunnel_arg(
    mocked_findPorts, mocked_serial, mocked_open, mock_get, mock_set, mock_platform_system, caplog, iface_with_nodes, capsys
):
    &#34;&#34;&#34;Test tunnel with tunnel arg (act like we are on a linux system)&#34;&#34;&#34;

    # Override the time.sleep so there is no loop
    def my_sleep(amount):
        print(f&#34;{amount}&#34;)
        sys.exit(3)

    a_mock = MagicMock()
    a_mock.return_value = &#34;Linux&#34;
    mock_platform_system.side_effect = a_mock
    sys.argv = [&#34;&#34;, &#34;--tunnel&#34;]
    mt_config.args = sys.argv

    serialInterface = SerialInterface(noProto=True)

    with caplog.at_level(logging.DEBUG):
        with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=serialInterface):
            with patch(&#34;time.sleep&#34;, side_effect=my_sleep):
                with pytest.raises(SystemExit) as pytest_wrapped_e:
                    tunnelMain()
                    mock_platform_system.assert_called()
                assert pytest_wrapped_e.type == SystemExit
                assert pytest_wrapped_e.value.code == 3
                assert re.search(r&#34;Not starting Tunnel&#34;, caplog.text, re.MULTILINE)
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="meshtastic.tests.test_main.test_main_ch_add_but_name_already_exists"><code class="name flex">
<span>def <span class="ident">test_main_ch_add_but_name_already_exists</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;ch-add with a channel name that already exists</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_add_but_name_already_exists(capsys):
    &#34;&#34;&#34;Test --ch-add with a channel name that already exists&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-add&#34;, &#34;testing&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)
    # set it up so we do not already have a channel named this
    mocked_node.getChannelByName.return_value = True

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Warning: This node already has&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_ch_add_but_no_more_channels"><code class="name flex">
<span>def <span class="ident">test_main_ch_add_but_no_more_channels</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;ch-add with but there are no more channels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_add_but_no_more_channels(capsys):
    &#34;&#34;&#34;Test --ch-add with but there are no more channels&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-add&#34;, &#34;testing&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)
    # set it up so we do not already have a channel named this
    mocked_node.getChannelByName.return_value = False
    # set it up so we have free channels
    mocked_node.getDisabledChannel.return_value = None

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Warning: No free channels were found&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_ch_add_invalid_name_too_long"><code class="name flex">
<span>def <span class="ident">test_main_ch_add_invalid_name_too_long</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;ch-add with invalid channel name, name too long</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_add_invalid_name_too_long(capsys):
    &#34;&#34;&#34;Test --ch-add with invalid channel name, name too long&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-add&#34;, &#34;testingtestingtesting&#34;]
    mt_config.args = sys.argv

    mocked_channel = MagicMock(autospec=Channel)
    # TODO: figure out how to get it to print the channel name instead of MagicMock

    mocked_node = MagicMock(autospec=Node)
    # set it up so we do not already have a channel named this
    mocked_node.getChannelByName.return_value = False
    # set it up so we have free channels
    mocked_node.getDisabledChannel.return_value = mocked_channel

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Warning: Channel name must be shorter&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_ch_add_valid"><code class="name flex">
<span>def <span class="ident">test_main_ch_add_valid</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;ch-add with valid channel name, and that channel name does not already exist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_add_valid(capsys):
    &#34;&#34;&#34;Test --ch-add with valid channel name, and that channel name does not already exist&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-add&#34;, &#34;testing&#34;]
    mt_config.args = sys.argv

    mocked_channel = MagicMock(autospec=Channel)
    # TODO: figure out how to get it to print the channel name instead of MagicMock

    mocked_node = MagicMock(autospec=Node)
    # set it up so we do not already have a channel named this
    mocked_node.getChannelByName.return_value = False
    # set it up so we have free channels
    mocked_node.getDisabledChannel.return_value = mocked_channel

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Writing modified channels to device&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_ch_del"><code class="name flex">
<span>def <span class="ident">test_main_ch_del</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;ch-del with valid secondary channel to be deleted</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_del(capsys):
    &#34;&#34;&#34;Test --ch-del with valid secondary channel to be deleted&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-del&#34;, &#34;--ch-index&#34;, &#34;1&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Deleting channel&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_ch_del_no_ch_index_specified"><code class="name flex">
<span>def <span class="ident">test_main_ch_del_no_ch_index_specified</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;ch-del without a valid ch-index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_del_no_ch_index_specified(capsys):
    &#34;&#34;&#34;Test --ch-del without a valid ch-index&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-del&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Warning: Need to specify&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_ch_del_primary_channel"><code class="name flex">
<span>def <span class="ident">test_main_ch_del_primary_channel</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;ch-del on ch-index=0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_del_primary_channel(capsys):
    &#34;&#34;&#34;Test --ch-del on ch-index=0&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-del&#34;, &#34;--ch-index&#34;, &#34;0&#34;]
    mt_config.args = sys.argv
    mt_config.channel_index = 1

    mocked_node = MagicMock(autospec=Node)

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Warning: Cannot delete primary channel&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_ch_disable_valid_secondary_channel"><code class="name flex">
<span>def <span class="ident">test_main_ch_disable_valid_secondary_channel</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;ch-disable with &ndash;ch-index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_disable_valid_secondary_channel(capsys):
    &#34;&#34;&#34;Test --ch-disable with --ch-index&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-disable&#34;, &#34;--ch-index&#34;, &#34;1&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Writing modified channels&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        assert mt_config.channel_index == 1
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_ch_enable_primary_channel"><code class="name flex">
<span>def <span class="ident">test_main_ch_enable_primary_channel</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;ch-enable with &ndash;ch-index = 0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_enable_primary_channel(capsys):
    &#34;&#34;&#34;Test --ch-enable with --ch-index = 0&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-enable&#34;, &#34;--ch-index&#34;, &#34;0&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Warning: Cannot enable/disable PRIMARY&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        assert mt_config.channel_index == 0
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_ch_enable_valid_secondary_channel"><code class="name flex">
<span>def <span class="ident">test_main_ch_enable_valid_secondary_channel</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;ch-enable with &ndash;ch-index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_enable_valid_secondary_channel(capsys):
    &#34;&#34;&#34;Test --ch-enable with --ch-index&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-enable&#34;, &#34;--ch-index&#34;, &#34;1&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Writing modified channels&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        assert mt_config.channel_index == 1
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_ch_enable_without_a_ch_index"><code class="name flex">
<span>def <span class="ident">test_main_ch_enable_without_a_ch_index</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;ch-enable without &ndash;ch-index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_enable_without_a_ch_index(capsys):
    &#34;&#34;&#34;Test --ch-enable without --ch-index&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-enable&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Warning: Need to specify&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        assert mt_config.channel_index is None
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_ch_index_no_devices"><code class="name flex">
<span>def <span class="ident">test_main_ch_index_no_devices</span></span>(<span>patched_find_ports, capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;ch-index 1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[])
def test_main_ch_index_no_devices(patched_find_ports, capsys):
    &#34;&#34;&#34;Test --ch-index 1&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-index&#34;, &#34;1&#34;]
    mt_config.args = sys.argv

    with pytest.raises(SystemExit) as pytest_wrapped_e:
        main()
    assert mt_config.channel_index == 1
    assert pytest_wrapped_e.type == SystemExit
    assert pytest_wrapped_e.value.code == 1
    out, err = capsys.readouterr()
    assert re.search(r&#34;No.*Meshtastic.*device.*detected&#34;, out, re.MULTILINE)
    assert err == &#34;&#34;
    patched_find_ports.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_ch_longfast_on_non_primary_channel"><code class="name flex">
<span>def <span class="ident">test_main_ch_longfast_on_non_primary_channel</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;ch-longfast &ndash;ch-index 1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_longfast_on_non_primary_channel(capsys):
    &#34;&#34;&#34;Test --ch-longfast --ch-index 1&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-longfast&#34;, &#34;--ch-index&#34;, &#34;1&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Warning: Cannot set modem preset for non-primary channel&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_ch_set_psk_no_ch_index"><code class="name flex">
<span>def <span class="ident">test_main_ch_set_psk_no_ch_index</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;ch-set psk</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_set_psk_no_ch_index(capsys):
    &#34;&#34;&#34;Test --ch-set psk&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--ch-set&#34;, &#34;psk&#34;, &#34;foo&#34;, &#34;--host&#34;, &#34;meshtastic.local&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=TCPInterface)
    with patch(&#34;meshtastic.tcp_interface.TCPInterface&#34;, return_value=iface) as mo:
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Warning: Need to specify &#39;--ch-index&#39;&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_ch_set_psk_with_ch_index"><code class="name flex">
<span>def <span class="ident">test_main_ch_set_psk_with_ch_index</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;ch-set psk</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_ch_set_psk_with_ch_index(capsys):
    &#34;&#34;&#34;Test --ch-set psk&#34;&#34;&#34;
    sys.argv = [
        &#34;&#34;,
        &#34;--ch-set&#34;,
        &#34;psk&#34;,
        &#34;foo&#34;,
        &#34;--host&#34;,
        &#34;meshtastic.local&#34;,
        &#34;--ch-index&#34;,
        &#34;0&#34;,
    ]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=TCPInterface)
    with patch(&#34;meshtastic.tcp_interface.TCPInterface&#34;, return_value=iface) as mo:
        main()
    out, err = capsys.readouterr()
    assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
    assert re.search(r&#34;Writing modified channels to device&#34;, out, re.MULTILINE)
    assert err == &#34;&#34;
    mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_configure_with_camel_case_keys"><code class="name flex">
<span>def <span class="ident">test_main_configure_with_camel_case_keys</span></span>(<span>mocked_findports, mocked_serial, mocked_open, mocked_get, mocked_set, capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;configure with valid file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;termios.tcsetattr&#34;)
@patch(&#34;termios.tcgetattr&#34;)
@patch(&#34;builtins.open&#34;, new_callable=mock_open, read_data=&#34;data&#34;)
@patch(&#34;serial.Serial&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[&#34;/dev/ttyUSBfake&#34;])
def test_main_configure_with_camel_case_keys(mocked_findports, mocked_serial, mocked_open, mocked_get, mocked_set, capsys):
    &#34;&#34;&#34;Test --configure with valid file&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--configure&#34;, &#34;exampleConfig.yaml&#34;]
    mt_config.args = sys.argv

    serialInterface = SerialInterface(noProto=True)
    anode = Node(serialInterface, 1234567890, noProto=True)
    serialInterface.localNode = anode

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=serialInterface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        # should these come back? maybe a flag?
        #assert re.search(r&#34;Setting device owner&#34;, out, re.MULTILINE)
        #assert re.search(r&#34;Setting device owner short&#34;, out, re.MULTILINE)
        #assert re.search(r&#34;Setting channel url&#34;, out, re.MULTILINE)
        #assert re.search(r&#34;Fixing altitude&#34;, out, re.MULTILINE)
        #assert re.search(r&#34;Fixing latitude&#34;, out, re.MULTILINE)
        #assert re.search(r&#34;Fixing longitude&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Writing modified configuration to device&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_configure_with_snake_case"><code class="name flex">
<span>def <span class="ident">test_main_configure_with_snake_case</span></span>(<span>mocked_findports, mocked_serial, mocked_open, mocked_get, mocked_set, capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;configure with valid file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;termios.tcsetattr&#34;)
@patch(&#34;termios.tcgetattr&#34;)
@patch(&#34;builtins.open&#34;, new_callable=mock_open, read_data=&#34;data&#34;)
@patch(&#34;serial.Serial&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[&#34;/dev/ttyUSBfake&#34;])
def test_main_configure_with_snake_case(mocked_findports, mocked_serial, mocked_open, mocked_get, mocked_set, capsys):
    &#34;&#34;&#34;Test --configure with valid file&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--configure&#34;, &#34;example_config.yaml&#34;]
    mt_config.args = sys.argv

    serialInterface = SerialInterface(noProto=True)
    anode = Node(serialInterface, 1234567890, noProto=True)
    serialInterface.localNode = anode

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=serialInterface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        # should these come back? maybe a flag?
        #assert re.search(r&#34;Setting device owner&#34;, out, re.MULTILINE)
        #assert re.search(r&#34;Setting device owner short&#34;, out, re.MULTILINE)
        #assert re.search(r&#34;Setting channel url&#34;, out, re.MULTILINE)
        #assert re.search(r&#34;Fixing altitude&#34;, out, re.MULTILINE)
        #assert re.search(r&#34;Fixing latitude&#34;, out, re.MULTILINE)
        #assert re.search(r&#34;Fixing longitude&#34;, out, re.MULTILINE)
        #assert re.search(r&#34;Set location_share to LocEnabled&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Writing modified configuration to device&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_export_config"><code class="name flex">
<span>def <span class="ident">test_main_export_config</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test export_config() function directly</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_export_config(capsys):
    &#34;&#34;&#34;Test export_config() function directly&#34;&#34;&#34;
    iface = MagicMock(autospec=SerialInterface)
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        mo.getLongName.return_value = &#34;foo&#34;
        mo.getShortName.return_value = &#34;oof&#34;
        mo.localNode.getURL.return_value = &#34;bar&#34;
        mo.getMyNodeInfo().get.return_value = {
            &#34;latitudeI&#34;: 1100000000,
            &#34;longitudeI&#34;: 1200000000,
            &#34;altitude&#34;: 100,
            &#34;batteryLevel&#34;: 34,
            &#34;latitude&#34;: 110.0,
            &#34;longitude&#34;: 120.0,
        }
        mo.localNode.radioConfig.preferences = &#34;&#34;&#34;phone_timeout_secs: 900
ls_secs: 300
position_broadcast_smart: true
fixed_position: true
position_flags: 35&#34;&#34;&#34;
        export_config(mo)
    out, err = capsys.readouterr()

    # ensure we do not output this line
    assert not re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)

    assert re.search(r&#34;owner: foo&#34;, out, re.MULTILINE)
    assert re.search(r&#34;owner_short: oof&#34;, out, re.MULTILINE)
    assert re.search(r&#34;channel_url: bar&#34;, out, re.MULTILINE)
    assert re.search(r&#34;location:&#34;, out, re.MULTILINE)
    assert re.search(r&#34;lat: 110.0&#34;, out, re.MULTILINE)
    assert re.search(r&#34;lon: 120.0&#34;, out, re.MULTILINE)
    assert re.search(r&#34;alt: 100&#34;, out, re.MULTILINE)
    # TODO: rework above config to test the following
    #assert re.search(r&#34;user_prefs:&#34;, out, re.MULTILINE)
    #assert re.search(r&#34;phone_timeout_secs: 900&#34;, out, re.MULTILINE)
    #assert re.search(r&#34;ls_secs: 300&#34;, out, re.MULTILINE)
    #assert re.search(r&#34;position_broadcast_smart: &#39;true&#39;&#34;, out, re.MULTILINE)
    #assert re.search(r&#34;fixed_position: &#39;true&#39;&#34;, out, re.MULTILINE)
    #assert re.search(r&#34;position_flags: 35&#34;, out, re.MULTILINE)
    assert err == &#34;&#34;</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_get_canned_messages"><code class="name flex">
<span>def <span class="ident">test_main_get_canned_messages</span></span>(<span>capsys, caplog, iface_with_nodes)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;get-canned-message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_get_canned_messages(capsys, caplog, iface_with_nodes):
    &#34;&#34;&#34;Test --get-canned-message&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--get-canned-message&#34;]
    mt_config.args = sys.argv

    iface = iface_with_nodes
    iface.localNode.cannedPluginMessage = &#34;foo&#34;
    iface.devPath = &#34;bar&#34;

    with caplog.at_level(logging.DEBUG):
        with patch(
            &#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface
        ) as mo:
            main()
            out, err = capsys.readouterr()
            assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
            assert re.search(r&#34;canned_plugin_message:foo&#34;, out, re.MULTILINE)
            assert err == &#34;&#34;
            mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_get_with_invalid"><code class="name flex">
<span>def <span class="ident">test_main_get_with_invalid</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;get with invalid field</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_get_with_invalid(capsys):
    &#34;&#34;&#34;Test --get with invalid field&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--get&#34;, &#34;foo&#34;]
    mt_config.args = sys.argv

    mocked_user_prefs = MagicMock()
    mocked_user_prefs.DESCRIPTOR.fields_by_name.get.return_value = None

    mocked_node = MagicMock(autospec=Node)
    mocked_node.localConfig = mocked_user_prefs
    mocked_node.moduleConfig = mocked_user_prefs

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;do not have attribute foo&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Choices are...&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_gpio_rd_no_dest"><code class="name flex">
<span>def <span class="ident">test_main_gpio_rd_no_dest</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;gpio_rd with a named gpio channel but no dest was specified</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_gpio_rd_no_dest(capsys):
    &#34;&#34;&#34;Test --gpio_rd with a named gpio channel but no dest was specified&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--gpio-rd&#34;, &#34;0x2000&#34;]
    mt_config.args = sys.argv

    channel = Channel(index=2, role=2)
    channel.settings.psk = b&#34;\x8a\x94y\x0e\xc6\xc9\x1e5\x91\x12@\xa60\xa8\xb43\x87\x00\xf2K\x0e\xe7\x7fAz\xcd\xf5\xb0\x900\xa84&#34;
    channel.settings.name = &#34;gpio&#34;

    iface = MagicMock(autospec=SerialInterface)
    iface.localNode.getChannelByName.return_value = channel
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface):
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;Warning: Must use a destination node ID&#34;, out)
        assert err == &#34;&#34;</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_gpio_rd_no_gpio_channel"><code class="name flex">
<span>def <span class="ident">test_main_gpio_rd_no_gpio_channel</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;gpio_rd with no named gpio channel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_gpio_rd_no_gpio_channel(capsys):
    &#34;&#34;&#34;Test --gpio_rd with no named gpio channel&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--gpio-rd&#34;, &#34;0x10&#34;, &#34;--dest&#34;, &#34;!foo&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)
    iface.localNode.getChannelByName.return_value = None
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface):
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;Warning: No channel named&#34;, out)
        assert err == &#34;&#34;</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_info"><code class="name flex">
<span>def <span class="ident">test_main_info</span></span>(<span>capsys, caplog)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;info</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_info(capsys, caplog):
    &#34;&#34;&#34;Test --info&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--info&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)

    def mock_showInfo():
        print(&#34;inside mocked showInfo&#34;)

    iface.showInfo.side_effect = mock_showInfo
    with caplog.at_level(logging.DEBUG):
        with patch(
            &#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface
        ) as mo:
            main()
            out, err = capsys.readouterr()
            assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
            assert re.search(r&#34;inside mocked showInfo&#34;, out, re.MULTILINE)
            assert err == &#34;&#34;
            mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_info_with_permission_error"><code class="name flex">
<span>def <span class="ident">test_main_info_with_permission_error</span></span>(<span>patched_getlogin, capsys, caplog)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;info</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;os.getlogin&#34;)
def test_main_info_with_permission_error(patched_getlogin, capsys, caplog):
    &#34;&#34;&#34;Test --info&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--info&#34;]
    mt_config.args = sys.argv

    patched_getlogin.return_value = &#34;me&#34;

    iface = MagicMock(autospec=SerialInterface)
    with caplog.at_level(logging.DEBUG):
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            with patch(
                &#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface
            ) as mo:
                mo.side_effect = PermissionError(&#34;bla bla&#34;)
                main()
            assert pytest_wrapped_e.type == SystemExit
            assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        patched_getlogin.assert_called()
        assert re.search(r&#34;Need to add yourself&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_info_with_seriallog_output_txt"><code class="name flex">
<span>def <span class="ident">test_main_info_with_seriallog_output_txt</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;info</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_info_with_seriallog_output_txt(capsys):
    &#34;&#34;&#34;Test --info&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--info&#34;, &#34;--seriallog&#34;, &#34;output.txt&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)

    def mock_showInfo():
        print(&#34;inside mocked showInfo&#34;)

    iface.showInfo.side_effect = mock_showInfo
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked showInfo&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()
    # do some cleanup
    os.remove(&#34;output.txt&#34;)</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_info_with_seriallog_stdout"><code class="name flex">
<span>def <span class="ident">test_main_info_with_seriallog_stdout</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;info</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_info_with_seriallog_stdout(capsys):
    &#34;&#34;&#34;Test --info&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--info&#34;, &#34;--seriallog&#34;, &#34;stdout&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)

    def mock_showInfo():
        print(&#34;inside mocked showInfo&#34;)

    iface.showInfo.side_effect = mock_showInfo
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked showInfo&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_info_with_tcp_interface"><code class="name flex">
<span>def <span class="ident">test_main_info_with_tcp_interface</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;info</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_info_with_tcp_interface(capsys):
    &#34;&#34;&#34;Test --info&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--info&#34;, &#34;--host&#34;, &#34;meshtastic.local&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=TCPInterface)

    def mock_showInfo():
        print(&#34;inside mocked showInfo&#34;)

    iface.showInfo.side_effect = mock_showInfo
    with patch(&#34;meshtastic.tcp_interface.TCPInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked showInfo&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_init_parser_no_args"><code class="name flex">
<span>def <span class="ident">test_main_init_parser_no_args</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test no arguments</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_init_parser_no_args(capsys):
    &#34;&#34;&#34;Test no arguments&#34;&#34;&#34;
    sys.argv = [&#34;&#34;]
    mt_config.args = sys.argv
    initParser()
    out, err = capsys.readouterr()
    assert out == &#34;&#34;
    assert err == &#34;&#34;</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_init_parser_version"><code class="name flex">
<span>def <span class="ident">test_main_init_parser_version</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;version</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_init_parser_version(capsys):
    &#34;&#34;&#34;Test --version&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--version&#34;]
    mt_config.args = sys.argv

    with pytest.raises(SystemExit) as pytest_wrapped_e:
        initParser()
    assert pytest_wrapped_e.type == SystemExit
    assert pytest_wrapped_e.value.code == 0
    out, err = capsys.readouterr()
    assert re.match(r&#34;[0-9]+\.[0-9]+[\.a][0-9]&#34;, out)
    assert err == &#34;&#34;</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_main_no_args"><code class="name flex">
<span>def <span class="ident">test_main_main_no_args</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test with no args</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_main_no_args(capsys):
    &#34;&#34;&#34;Test with no args&#34;&#34;&#34;
    sys.argv = [&#34;&#34;]
    mt_config.args = sys.argv

    with pytest.raises(SystemExit) as pytest_wrapped_e:
        main()
    assert pytest_wrapped_e.type == SystemExit
    assert pytest_wrapped_e.value.code == 1
    _, err = capsys.readouterr()
    assert re.search(r&#34;usage:&#34;, err, re.MULTILINE)</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_main_version"><code class="name flex">
<span>def <span class="ident">test_main_main_version</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;version</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_main_version(capsys):
    &#34;&#34;&#34;Test --version&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--version&#34;]
    mt_config.args = sys.argv

    with pytest.raises(SystemExit) as pytest_wrapped_e:
        main()
    assert pytest_wrapped_e.type == SystemExit
    assert pytest_wrapped_e.value.code == 0
    out, err = capsys.readouterr()
    assert re.match(r&#34;[0-9]+\.[0-9]+[\.a][0-9]&#34;, out)
    assert err == &#34;&#34;</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_no_proto"><code class="name flex">
<span>def <span class="ident">test_main_no_proto</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;noproto (using &ndash;info for output)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_no_proto(capsys):
    &#34;&#34;&#34;Test --noproto (using --info for output)&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--info&#34;, &#34;--noproto&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)

    def mock_showInfo():
        print(&#34;inside mocked showInfo&#34;)

    iface.showInfo.side_effect = mock_showInfo

    # Override the time.sleep so there is no loop
    def my_sleep(amount):
        print(f&#34;amount:{amount}&#34;)
        sys.exit(0)

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface):
        with patch(&#34;time.sleep&#34;, side_effect=my_sleep):
            with pytest.raises(SystemExit) as pytest_wrapped_e:
                main()
            assert pytest_wrapped_e.type == SystemExit
            assert pytest_wrapped_e.value.code == 0
            out, err = capsys.readouterr()
            assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
            assert re.search(r&#34;inside mocked showInfo&#34;, out, re.MULTILINE)
            assert err == &#34;&#34;</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_nodes"><code class="name flex">
<span>def <span class="ident">test_main_nodes</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;nodes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_nodes(capsys):
    &#34;&#34;&#34;Test --nodes&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--nodes&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)

    def mock_showNodes():
        print(&#34;inside mocked showNodes&#34;)

    iface.showNodes.side_effect = mock_showNodes
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked showNodes&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_onConnected_exception"><code class="name flex">
<span>def <span class="ident">test_main_onConnected_exception</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test the exception in onConnected</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_onConnected_exception(capsys):
    &#34;&#34;&#34;Test the exception in onConnected&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--qr&#34;]
    mt_config.args = sys.argv

    def throw_an_exception(junk):
        raise Exception(&#34;Fake exception.&#34;) # pylint: disable=W0719

    iface = MagicMock(autospec=SerialInterface)
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface):
        with patch(&#34;pyqrcode.create&#34;, side_effect=throw_an_exception):
            with pytest.raises(SystemExit) as pytest_wrapped_e:
                main()
                out, err = capsys.readouterr()
                assert re.search(&#34;Aborting due to: Fake exception&#34;, out, re.MULTILINE)
                assert err == &#34;&#34;
                assert pytest_wrapped_e.type == Exception</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_onConnection"><code class="name flex">
<span>def <span class="ident">test_main_onConnection</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test onConnection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_onConnection(capsys):
    &#34;&#34;&#34;Test onConnection&#34;&#34;&#34;
    sys.argv = [&#34;&#34;]
    mt_config.args = sys.argv
    iface = MagicMock(autospec=SerialInterface)

    class TempTopic:
        &#34;&#34;&#34;temp class for topic&#34;&#34;&#34;

        def getName(self):
            &#34;&#34;&#34;return the fake name of a topic&#34;&#34;&#34;
            return &#34;foo&#34;

    mytopic = TempTopic()
    onConnection(iface, mytopic)
    out, err = capsys.readouterr()
    assert re.search(r&#34;Connection changed: foo&#34;, out, re.MULTILINE)
    assert err == &#34;&#34;</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_onReceive_empty"><code class="name flex">
<span>def <span class="ident">test_main_onReceive_empty</span></span>(<span>caplog, capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test onReceive</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_onReceive_empty(caplog, capsys):
    &#34;&#34;&#34;Test onReceive&#34;&#34;&#34;
    args = MagicMock()
    mt_config.args = args
    iface = MagicMock(autospec=SerialInterface)
    packet = {}
    with caplog.at_level(logging.DEBUG):
        onReceive(packet, iface)
    assert re.search(r&#34;in onReceive&#34;, caplog.text, re.MULTILINE)
    out, err = capsys.readouterr()
    assert re.search(
        r&#34;Warning: There is no field &#39;to&#39; in the packet.&#34;, out, re.MULTILINE
    )
    assert err == &#34;&#34;</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_onReceive_with_sendtext"><code class="name flex">
<span>def <span class="ident">test_main_onReceive_with_sendtext</span></span>(<span>caplog, capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test onReceive with sendtext
The entire point of this test is to make sure the interface.close() call
is made in onReceive().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_onReceive_with_sendtext(caplog, capsys):
    &#34;&#34;&#34;Test onReceive with sendtext
    The entire point of this test is to make sure the interface.close() call
    is made in onReceive().
    &#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--sendtext&#34;, &#34;hello&#34;]
    mt_config.args = sys.argv

    # Note: &#39;TEXT_MESSAGE_APP&#39; value is 1
    packet = {
        &#34;to&#34;: 4294967295,
        &#34;decoded&#34;: {&#34;portnum&#34;: 1, &#34;payload&#34;: &#34;hello&#34;},
        &#34;id&#34;: 334776977,
        &#34;hop_limit&#34;: 3,
        &#34;want_ack&#34;: True,
    }

    iface = MagicMock(autospec=SerialInterface)
    iface.myInfo.my_node_num = 4294967295

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        with caplog.at_level(logging.DEBUG):
            main()
            onReceive(packet, iface)
        assert re.search(r&#34;in onReceive&#34;, caplog.text, re.MULTILINE)
        mo.assert_called()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Sending text message hello to&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_onReceive_with_text"><code class="name flex">
<span>def <span class="ident">test_main_onReceive_with_text</span></span>(<span>caplog, capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test onReceive with text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_onReceive_with_text(caplog, capsys):
    &#34;&#34;&#34;Test onReceive with text&#34;&#34;&#34;
    args = MagicMock()
    args.sendtext.return_value = &#34;foo&#34;
    mt_config.args = args

    # Note: &#39;TEXT_MESSAGE_APP&#39; value is 1
    # Note: Some of this is faked below.
    packet = {
        &#34;to&#34;: 4294967295,
        &#34;decoded&#34;: {&#34;portnum&#34;: 1, &#34;payload&#34;: &#34;hello&#34;, &#34;text&#34;: &#34;faked&#34;},
        &#34;id&#34;: 334776977,
        &#34;hop_limit&#34;: 3,
        &#34;want_ack&#34;: True,
        &#34;rxSnr&#34;: 6.0,
        &#34;hopLimit&#34;: 3,
        &#34;raw&#34;: &#34;faked&#34;,
        &#34;fromId&#34;: &#34;!28b5465c&#34;,
        &#34;toId&#34;: &#34;^all&#34;,
    }

    iface = MagicMock(autospec=SerialInterface)
    iface.myInfo.my_node_num = 4294967295

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface):
        with caplog.at_level(logging.DEBUG):
            onReceive(packet, iface)
        assert re.search(r&#34;in onReceive&#34;, caplog.text, re.MULTILINE)
        out, err = capsys.readouterr()
        assert re.search(r&#34;Sending reply&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_qr"><code class="name flex">
<span>def <span class="ident">test_main_qr</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;qr</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_qr(capsys):
    &#34;&#34;&#34;Test --qr&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--qr&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)
    # TODO: could mock/check url
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Primary channel URL&#34;, out, re.MULTILINE)
        # if a qr code is generated it will have lots of these
        assert re.search(r&#34;\[7m&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_reboot"><code class="name flex">
<span>def <span class="ident">test_main_reboot</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;reboot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_reboot(capsys):
    &#34;&#34;&#34;Test --reboot&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--reboot&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    def mock_reboot():
        print(&#34;inside mocked reboot&#34;)

    mocked_node.reboot.side_effect = mock_reboot

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked reboot&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_removeposition"><code class="name flex">
<span>def <span class="ident">test_main_removeposition</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;remove-position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_removeposition(capsys):
    &#34;&#34;&#34;Test --remove-position&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--remove-position&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    def mock_removeFixedPosition():
        print(&#34;inside mocked removeFixedPosition&#34;)

    mocked_node.removeFixedPosition.side_effect = mock_removeFixedPosition

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Removing fixed position&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked removeFixedPosition&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_removeposition_remote"><code class="name flex">
<span>def <span class="ident">test_main_removeposition_remote</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;remove-position with a remote dest</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_removeposition_remote(capsys):
    &#34;&#34;&#34;Test --remove-position with a remote dest&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--remove-position&#34;, &#34;--dest&#34;, &#34;!12345678&#34;]
    mt_config.args = sys.argv
    iface = MagicMock(autospec=SerialInterface)
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Removing fixed position and disabling fixed position setting&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Waiting for an acknowledgment from remote node&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_sendtext"><code class="name flex">
<span>def <span class="ident">test_main_sendtext</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;sendtext</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_sendtext(capsys):
    &#34;&#34;&#34;Test --sendtext&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--sendtext&#34;, &#34;hello&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)

    def mock_sendText(
        text, dest, wantAck=False, wantResponse=False, onResponse=None, channelIndex=0
    ):
        print(&#34;inside mocked sendText&#34;)
        print(f&#34;{text} {dest} {wantAck} {wantResponse} {channelIndex}&#34;)

    iface.sendText.side_effect = mock_sendText

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Sending text message&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked sendText&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_sendtext_with_channel"><code class="name flex">
<span>def <span class="ident">test_main_sendtext_with_channel</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;sendtext</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_sendtext_with_channel(capsys):
    &#34;&#34;&#34;Test --sendtext&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--sendtext&#34;, &#34;hello&#34;, &#34;--ch-index&#34;, &#34;1&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)

    def mock_sendText(
        text, dest, wantAck=False, wantResponse=False, onResponse=None, channelIndex=0
    ):
        print(&#34;inside mocked sendText&#34;)
        print(f&#34;{text} {dest} {wantAck} {wantResponse} {channelIndex}&#34;)

    iface.sendText.side_effect = mock_sendText

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Sending text message&#34;, out, re.MULTILINE)
        assert re.search(r&#34;on channelIndex:1&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked sendText&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_sendtext_with_dest"><code class="name flex">
<span>def <span class="ident">test_main_sendtext_with_dest</span></span>(<span>mock_findPorts, mock_serial, mocked_open, mock_get, mock_set, capsys, caplog, iface_with_nodes)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;sendtext with &ndash;dest</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;termios.tcsetattr&#34;)
@patch(&#34;termios.tcgetattr&#34;)
@patch(&#34;builtins.open&#34;, new_callable=mock_open, read_data=&#34;data&#34;)
@patch(&#34;serial.Serial&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[&#34;/dev/ttyUSBfake&#34;])
def test_main_sendtext_with_dest(mock_findPorts, mock_serial, mocked_open, mock_get, mock_set, capsys, caplog, iface_with_nodes):
    &#34;&#34;&#34;Test --sendtext with --dest&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--sendtext&#34;, &#34;hello&#34;, &#34;--dest&#34;, &#34;foo&#34;]
    mt_config.args = sys.argv

    #iface = iface_with_nodes
    #iface.myInfo.my_node_num = 2475227164
    serialInterface = SerialInterface(noProto=True)

    mocked_channel = MagicMock(autospec=Channel)
    serialInterface.localNode.getChannelByChannelIndex = mocked_channel

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=serialInterface):
        with caplog.at_level(logging.DEBUG):
            #with pytest.raises(SystemExit) as pytest_wrapped_e:
            main()
            #assert pytest_wrapped_e.type == SystemExit
            #assert pytest_wrapped_e.value.code == 1
            out, err = capsys.readouterr()
            assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
            assert not re.search(
                r&#34;Warning: 0 is not a valid channel&#34;, out, re.MULTILINE
            )
            assert not re.search(
                r&#34;There is a SECONDARY channel named &#39;admin&#39;&#34;, out, re.MULTILINE
            )
            print(out)
            assert re.search(r&#34;Not sending packet because&#34;, caplog.text, re.MULTILINE)
            assert re.search(r&#34;Warning: There were no self.nodes.&#34;, caplog.text, re.MULTILINE)
            assert err == &#34;&#34;</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_sendtext_with_invalid_channel"><code class="name flex">
<span>def <span class="ident">test_main_sendtext_with_invalid_channel</span></span>(<span>caplog, capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;sendtext</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_sendtext_with_invalid_channel(caplog, capsys):
    &#34;&#34;&#34;Test --sendtext&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--sendtext&#34;, &#34;hello&#34;, &#34;--ch-index&#34;, &#34;-1&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)
    iface.localNode.getChannelByChannelIndex.return_value = None

    with caplog.at_level(logging.DEBUG):
        with patch(
            &#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface
        ) as mo:
            with pytest.raises(SystemExit) as pytest_wrapped_e:
                main()
            assert pytest_wrapped_e.type == SystemExit
            assert pytest_wrapped_e.value.code == 1
            out, err = capsys.readouterr()
            assert re.search(r&#34;is not a valid channel&#34;, out, re.MULTILINE)
            assert err == &#34;&#34;
            mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_sendtext_with_invalid_channel_nine"><code class="name flex">
<span>def <span class="ident">test_main_sendtext_with_invalid_channel_nine</span></span>(<span>caplog, capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;sendtext</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_sendtext_with_invalid_channel_nine(caplog, capsys):
    &#34;&#34;&#34;Test --sendtext&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--sendtext&#34;, &#34;hello&#34;, &#34;--ch-index&#34;, &#34;9&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)
    iface.localNode.getChannelByChannelIndex.return_value = None

    with caplog.at_level(logging.DEBUG):
        with patch(
            &#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface
        ) as mo:
            with pytest.raises(SystemExit) as pytest_wrapped_e:
                main()
            assert pytest_wrapped_e.type == SystemExit
            assert pytest_wrapped_e.value.code == 1
            out, err = capsys.readouterr()
            assert re.search(r&#34;is not a valid channel&#34;, out, re.MULTILINE)
            assert err == &#34;&#34;
            mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_set_canned_messages"><code class="name flex">
<span>def <span class="ident">test_main_set_canned_messages</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;set-canned-message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_set_canned_messages(capsys):
    &#34;&#34;&#34;Test --set-canned-message&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--set-canned-message&#34;, &#34;foo&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Setting canned plugin message to foo&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_set_ham_to_KI123"><code class="name flex">
<span>def <span class="ident">test_main_set_ham_to_KI123</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;set-ham KI123</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_set_ham_to_KI123(capsys):
    &#34;&#34;&#34;Test --set-ham KI123&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--set-ham&#34;, &#34;KI123&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    def mock_turnOffEncryptionOnPrimaryChannel():
        print(&#34;inside mocked turnOffEncryptionOnPrimaryChannel&#34;)

    def mock_setOwner(name, is_licensed):
        print(f&#34;inside mocked setOwner name:{name} is_licensed:{is_licensed}&#34;)

    mocked_node.turnOffEncryptionOnPrimaryChannel.side_effect = (
        mock_turnOffEncryptionOnPrimaryChannel
    )
    mocked_node.setOwner.side_effect = mock_setOwner

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Setting Ham ID to KI123&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked setOwner&#34;, out, re.MULTILINE)
        assert re.search(
            r&#34;inside mocked turnOffEncryptionOnPrimaryChannel&#34;, out, re.MULTILINE
        )
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_set_invalid_wifi_psk"><code class="name flex">
<span>def <span class="ident">test_main_set_invalid_wifi_psk</span></span>(<span>mocked_findports, mocked_serial, mocked_open, mocked_get, mocked_set, capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;set with an invalid value (psk must be 8 or more characters)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;termios.tcsetattr&#34;)
@patch(&#34;termios.tcgetattr&#34;)
@patch(&#34;builtins.open&#34;, new_callable=mock_open, read_data=&#34;data&#34;)
@patch(&#34;serial.Serial&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[&#34;/dev/ttyUSBfake&#34;])
def test_main_set_invalid_wifi_psk(mocked_findports, mocked_serial, mocked_open, mocked_get, mocked_set, capsys):
    &#34;&#34;&#34;Test --set with an invalid value (psk must be 8 or more characters)&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--set&#34;, &#34;network.wifi_psk&#34;, &#34;1234567&#34;]
    mt_config.args = sys.argv

    serialInterface = SerialInterface(noProto=True)
    anode = Node(serialInterface, 1234567890, noProto=True)
    serialInterface.localNode = anode

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=serialInterface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert not re.search(r&#34;Set network.wifi_psk to 1234567&#34;, out, re.MULTILINE)
        assert re.search(
            r&#34;Warning: network.wifi_psk must be 8 or more characters.&#34;, out, re.MULTILINE
        )
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_set_owner_short_to_bob"><code class="name flex">
<span>def <span class="ident">test_main_set_owner_short_to_bob</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;set-owner-short bob</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_set_owner_short_to_bob(capsys):
    &#34;&#34;&#34;Test --set-owner-short bob&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--set-owner-short&#34;, &#34;bob&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Setting device owner short to bob&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_set_owner_to_bob"><code class="name flex">
<span>def <span class="ident">test_main_set_owner_to_bob</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;set-owner bob</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_set_owner_to_bob(capsys):
    &#34;&#34;&#34;Test --set-owner bob&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--set-owner&#34;, &#34;bob&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Setting device owner to bob&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_set_valid"><code class="name flex">
<span>def <span class="ident">test_main_set_valid</span></span>(<span>mocked_findports, mocked_serial, mocked_open, mocked_get, mocked_set, capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;set with valid field</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;termios.tcsetattr&#34;)
@patch(&#34;termios.tcgetattr&#34;)
@patch(&#34;builtins.open&#34;, new_callable=mock_open, read_data=&#34;data&#34;)
@patch(&#34;serial.Serial&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[&#34;/dev/ttyUSBfake&#34;])
def test_main_set_valid(mocked_findports, mocked_serial, mocked_open, mocked_get, mocked_set, capsys):
    &#34;&#34;&#34;Test --set with valid field&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--set&#34;, &#34;network.wifi_ssid&#34;, &#34;foo&#34;]
    mt_config.args = sys.argv

    serialInterface = SerialInterface(noProto=True)
    anode = Node(serialInterface, 1234567890, noProto=True)
    serialInterface.localNode = anode

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=serialInterface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Set network.wifi_ssid to foo&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_set_valid_camel_case"><code class="name flex">
<span>def <span class="ident">test_main_set_valid_camel_case</span></span>(<span>mocked_findports, mocked_serial, mocked_open, mocked_get, mocked_set, capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;set with valid field</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;termios.tcsetattr&#34;)
@patch(&#34;termios.tcgetattr&#34;)
@patch(&#34;builtins.open&#34;, new_callable=mock_open, read_data=&#34;data&#34;)
@patch(&#34;serial.Serial&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[&#34;/dev/ttyUSBfake&#34;])
def test_main_set_valid_camel_case(mocked_findports, mocked_serial, mocked_open, mocked_get, mocked_set, capsys):
    &#34;&#34;&#34;Test --set with valid field&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--set&#34;, &#34;network.wifi_ssid&#34;, &#34;foo&#34;]
    mt_config.args = sys.argv
    mt_config.camel_case = True

    serialInterface = SerialInterface(noProto=True)
    anode = Node(serialInterface, 1234567890, noProto=True)
    serialInterface.localNode = anode

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=serialInterface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Set network.wifiSsid to foo&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_set_valid_wifi_psk"><code class="name flex">
<span>def <span class="ident">test_main_set_valid_wifi_psk</span></span>(<span>mocked_findports, mocked_serial, mocked_open, mocked_get, mocked_set, capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;set with valid field</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;termios.tcsetattr&#34;)
@patch(&#34;termios.tcgetattr&#34;)
@patch(&#34;builtins.open&#34;, new_callable=mock_open, read_data=&#34;data&#34;)
@patch(&#34;serial.Serial&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[&#34;/dev/ttyUSBfake&#34;])
def test_main_set_valid_wifi_psk(mocked_findports, mocked_serial, mocked_open, mocked_get, mocked_set, capsys):
    &#34;&#34;&#34;Test --set with valid field&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--set&#34;, &#34;network.wifi_psk&#34;, &#34;123456789&#34;]
    mt_config.args = sys.argv

    serialInterface = SerialInterface(noProto=True)
    anode = Node(serialInterface, 1234567890, noProto=True)
    serialInterface.localNode = anode

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=serialInterface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Set network.wifi_psk to 123456789&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_set_with_invalid"><code class="name flex">
<span>def <span class="ident">test_main_set_with_invalid</span></span>(<span>mocked_findports, mocked_serial, mocked_open, mocked_get, mocked_set, capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;set with invalid field</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;termios.tcsetattr&#34;)
@patch(&#34;termios.tcgetattr&#34;)
@patch(&#34;builtins.open&#34;, new_callable=mock_open, read_data=&#34;data&#34;)
@patch(&#34;serial.Serial&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[&#34;/dev/ttyUSBfake&#34;])
def test_main_set_with_invalid(mocked_findports, mocked_serial, mocked_open, mocked_get, mocked_set, capsys):
    &#34;&#34;&#34;Test --set with invalid field&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--set&#34;, &#34;foo&#34;, &#34;foo&#34;]
    mt_config.args = sys.argv

    serialInterface = SerialInterface(noProto=True)
    anode = Node(serialInterface, 1234567890, noProto=True)
    serialInterface.localNode = anode

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=serialInterface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;do not have attribute foo&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_setalt"><code class="name flex">
<span>def <span class="ident">test_main_setalt</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;setalt</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_setalt(capsys):
    &#34;&#34;&#34;Test --setalt&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--setalt&#34;, &#34;51&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    def mock_setFixedPosition(lat, lon, alt):
        print(&#34;inside mocked setFixedPosition&#34;)
        print(f&#34;{lat} {lon} {alt}&#34;)

    mocked_node.setFixedPosition.side_effect = mock_setFixedPosition

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Fixing altitude&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Setting device position&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked setFixedPosition&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_setlat"><code class="name flex">
<span>def <span class="ident">test_main_setlat</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;setlat</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_setlat(capsys):
    &#34;&#34;&#34;Test --setlat&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--setlat&#34;, &#34;37.5&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    def mock_setFixedPosition(lat, lon, alt):
        print(&#34;inside mocked setFixedPosition&#34;)
        print(f&#34;{lat} {lon} {alt}&#34;)

    mocked_node.setFixedPosition.side_effect = mock_setFixedPosition

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Fixing latitude&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Setting device position&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked setFixedPosition&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_setlat_remote"><code class="name flex">
<span>def <span class="ident">test_main_setlat_remote</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;setlat with a remote dest</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_setlat_remote(capsys):
    &#34;&#34;&#34;Test --setlat with a remote dest&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--setlat&#34;, &#34;37.5&#34;, &#34;--dest&#34;, &#34;!12345678&#34;]
    mt_config.args = sys.argv
    iface = MagicMock(autospec=SerialInterface)
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Setting device position and enabling fixed position setting&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Waiting for an acknowledgment from remote node&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_setlon"><code class="name flex">
<span>def <span class="ident">test_main_setlon</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;setlon</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_setlon(capsys):
    &#34;&#34;&#34;Test --setlon&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--setlon&#34;, &#34;-122.1&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    def mock_setFixedPosition(lat, lon, alt):
        print(&#34;inside mocked setFixedPosition&#34;)
        print(f&#34;{lat} {lon} {alt}&#34;)

    mocked_node.setFixedPosition.side_effect = mock_setFixedPosition

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Fixing longitude&#34;, out, re.MULTILINE)
        assert re.search(r&#34;Setting device position&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked setFixedPosition&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_seturl"><code class="name flex">
<span>def <span class="ident">test_main_seturl</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;seturl (url used below is what is generated after a factory_reset)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_seturl(capsys):
    &#34;&#34;&#34;Test --seturl (url used below is what is generated after a factory_reset)&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--seturl&#34;, &#34;https://www.meshtastic.org/d/#CgUYAyIBAQ&#34;]
    mt_config.args = sys.argv

    iface = MagicMock(autospec=SerialInterface)
    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_shutdown"><code class="name flex">
<span>def <span class="ident">test_main_shutdown</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;shutdown</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_shutdown(capsys):
    &#34;&#34;&#34;Test --shutdown&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--shutdown&#34;]
    mt_config.args = sys.argv

    mocked_node = MagicMock(autospec=Node)

    def mock_shutdown():
        print(&#34;inside mocked shutdown&#34;)

    mocked_node.shutdown.side_effect = mock_shutdown

    iface = MagicMock(autospec=SerialInterface)
    iface.getNode.return_value = mocked_node

    with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=iface) as mo:
        main()
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert re.search(r&#34;inside mocked shutdown&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;
        mo.assert_called()</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_support"><code class="name flex">
<span>def <span class="ident">test_main_support</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;support</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_main_support(capsys):
    &#34;&#34;&#34;Test --support&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--support&#34;]
    mt_config.args = sys.argv

    with pytest.raises(SystemExit) as pytest_wrapped_e:
        main()
    assert pytest_wrapped_e.type == SystemExit
    assert pytest_wrapped_e.value.code == 0
    out, err = capsys.readouterr()
    assert re.search(r&#34;System&#34;, out, re.MULTILINE)
    assert re.search(r&#34;Platform&#34;, out, re.MULTILINE)
    assert re.search(r&#34;Machine&#34;, out, re.MULTILINE)
    assert re.search(r&#34;Executable&#34;, out, re.MULTILINE)
    assert err == &#34;&#34;</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_test_no_ports"><code class="name flex">
<span>def <span class="ident">test_main_test_no_ports</span></span>(<span>patched_find_ports, capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;test with no hardware</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[])
def test_main_test_no_ports(patched_find_ports, capsys):
    &#34;&#34;&#34;Test --test with no hardware&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--test&#34;]
    mt_config.args = sys.argv

    with pytest.raises(SystemExit) as pytest_wrapped_e:
        main()
    assert pytest_wrapped_e.type == SystemExit
    assert pytest_wrapped_e.value.code == 1
    patched_find_ports.assert_called()
    out, err = capsys.readouterr()
    assert re.search(
        r&#34;Warning: Must have at least two devices connected to USB&#34;, out, re.MULTILINE
    )
    assert err == &#34;&#34;</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_test_one_port"><code class="name flex">
<span>def <span class="ident">test_main_test_one_port</span></span>(<span>patched_find_ports, capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;test with one fake port</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[&#34;/dev/ttyFake1&#34;])
def test_main_test_one_port(patched_find_ports, capsys):
    &#34;&#34;&#34;Test --test with one fake port&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--test&#34;]
    mt_config.args = sys.argv

    with pytest.raises(SystemExit) as pytest_wrapped_e:
        main()
    assert pytest_wrapped_e.type == SystemExit
    assert pytest_wrapped_e.value.code == 1
    patched_find_ports.assert_called()
    out, err = capsys.readouterr()
    assert re.search(
        r&#34;Warning: Must have at least two devices connected to USB&#34;, out, re.MULTILINE
    )
    assert err == &#34;&#34;</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_test_two_ports_fails"><code class="name flex">
<span>def <span class="ident">test_main_test_two_ports_fails</span></span>(<span>patched_test_all, capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;test two fake ports and testAll() is a simulated failure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;meshtastic.test.testAll&#34;, return_value=False)
def test_main_test_two_ports_fails(patched_test_all, capsys):
    &#34;&#34;&#34;Test --test two fake ports and testAll() is a simulated failure&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--test&#34;]
    mt_config.args = sys.argv

    with pytest.raises(SystemExit) as pytest_wrapped_e:
        main()
    assert pytest_wrapped_e.type == SystemExit
    assert pytest_wrapped_e.value.code == 1
    patched_test_all.assert_called()
    out, err = capsys.readouterr()
    assert re.search(r&#34;Test was not successful.&#34;, out, re.MULTILINE)
    assert err == &#34;&#34;</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_main_test_two_ports_success"><code class="name flex">
<span>def <span class="ident">test_main_test_two_ports_success</span></span>(<span>patched_test_all, capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test &ndash;test two fake ports and testAll() is a simulated success</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;meshtastic.test.testAll&#34;, return_value=True)
def test_main_test_two_ports_success(patched_test_all, capsys):
    &#34;&#34;&#34;Test --test two fake ports and testAll() is a simulated success&#34;&#34;&#34;
    sys.argv = [&#34;&#34;, &#34;--test&#34;]
    mt_config.args = sys.argv

    with pytest.raises(SystemExit) as pytest_wrapped_e:
        main()
    assert pytest_wrapped_e.type == SystemExit
    assert pytest_wrapped_e.value.code == 0
    patched_test_all.assert_called()
    out, err = capsys.readouterr()
    assert re.search(r&#34;Test was a success.&#34;, out, re.MULTILINE)
    assert err == &#34;&#34;</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_onNode"><code class="name flex">
<span>def <span class="ident">test_onNode</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test onNode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_onNode(capsys):
    &#34;&#34;&#34;Test onNode&#34;&#34;&#34;
    onNode(&#34;foo&#34;)
    out, err = capsys.readouterr()
    assert re.search(r&#34;Node changed&#34;, out, re.MULTILINE)
    assert err == &#34;&#34;</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_tunnel_no_args"><code class="name flex">
<span>def <span class="ident">test_tunnel_no_args</span></span>(<span>capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test tunnel no arguments</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
def test_tunnel_no_args(capsys):
    &#34;&#34;&#34;Test tunnel no arguments&#34;&#34;&#34;
    sys.argv = [&#34;&#34;]
    mt_config.args = sys.argv
    with pytest.raises(SystemExit) as pytest_wrapped_e:
        tunnelMain()
    assert pytest_wrapped_e.type == SystemExit
    assert pytest_wrapped_e.value.code == 1
    _, err = capsys.readouterr()
    assert re.search(r&#34;usage: &#34;, err, re.MULTILINE)</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_tunnel_subnet_arg_with_no_devices"><code class="name flex">
<span>def <span class="ident">test_tunnel_subnet_arg_with_no_devices</span></span>(<span>mock_platform_system, caplog, capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test tunnel with subnet arg (act like we are on a linux system)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[])
@patch(&#34;platform.system&#34;)
def test_tunnel_subnet_arg_with_no_devices(mock_platform_system, caplog, capsys):
    &#34;&#34;&#34;Test tunnel with subnet arg (act like we are on a linux system)&#34;&#34;&#34;
    a_mock = MagicMock()
    a_mock.return_value = &#34;Linux&#34;
    mock_platform_system.side_effect = a_mock
    sys.argv = [&#34;&#34;, &#34;--subnet&#34;, &#34;foo&#34;]
    mt_config.args = sys.argv
    print(f&#34;platform.system():{platform.system()}&#34;)
    with caplog.at_level(logging.DEBUG):
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            tunnelMain()
        mock_platform_system.assert_called()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;No.*Meshtastic.*device.*detected&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_tunnel_tunnel_arg"><code class="name flex">
<span>def <span class="ident">test_tunnel_tunnel_arg</span></span>(<span>mocked_findPorts, mocked_serial, mocked_open, mock_get, mock_set, mock_platform_system, caplog, iface_with_nodes, capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test tunnel with tunnel arg (act like we are on a linux system)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;platform.system&#34;)
@patch(&#34;termios.tcsetattr&#34;)
@patch(&#34;termios.tcgetattr&#34;)
@patch(&#34;builtins.open&#34;, new_callable=mock_open, read_data=&#34;data&#34;)
@patch(&#34;serial.Serial&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[&#34;/dev/ttyUSBfake&#34;])
def test_tunnel_tunnel_arg(
    mocked_findPorts, mocked_serial, mocked_open, mock_get, mock_set, mock_platform_system, caplog, iface_with_nodes, capsys
):
    &#34;&#34;&#34;Test tunnel with tunnel arg (act like we are on a linux system)&#34;&#34;&#34;

    # Override the time.sleep so there is no loop
    def my_sleep(amount):
        print(f&#34;{amount}&#34;)
        sys.exit(3)

    a_mock = MagicMock()
    a_mock.return_value = &#34;Linux&#34;
    mock_platform_system.side_effect = a_mock
    sys.argv = [&#34;&#34;, &#34;--tunnel&#34;]
    mt_config.args = sys.argv

    serialInterface = SerialInterface(noProto=True)

    with caplog.at_level(logging.DEBUG):
        with patch(&#34;meshtastic.serial_interface.SerialInterface&#34;, return_value=serialInterface):
            with patch(&#34;time.sleep&#34;, side_effect=my_sleep):
                with pytest.raises(SystemExit) as pytest_wrapped_e:
                    tunnelMain()
                    mock_platform_system.assert_called()
                assert pytest_wrapped_e.type == SystemExit
                assert pytest_wrapped_e.value.code == 3
                assert re.search(r&#34;Not starting Tunnel&#34;, caplog.text, re.MULTILINE)
        out, err = capsys.readouterr()
        assert re.search(r&#34;Connected to radio&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;</code></pre>
</details>
</dd>
<dt id="meshtastic.tests.test_main.test_tunnel_tunnel_arg_with_no_devices"><code class="name flex">
<span>def <span class="ident">test_tunnel_tunnel_arg_with_no_devices</span></span>(<span>mock_platform_system, caplog, capsys)</span>
</code></dt>
<dd>
<div class="desc"><p>Test tunnel with tunnel arg (act like we are on a linux system)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.unit
@pytest.mark.usefixtures(&#34;reset_mt_config&#34;)
@patch(&#34;meshtastic.util.findPorts&#34;, return_value=[])
@patch(&#34;platform.system&#34;)
def test_tunnel_tunnel_arg_with_no_devices(mock_platform_system, caplog, capsys):
    &#34;&#34;&#34;Test tunnel with tunnel arg (act like we are on a linux system)&#34;&#34;&#34;
    a_mock = MagicMock()
    a_mock.return_value = &#34;Linux&#34;
    mock_platform_system.side_effect = a_mock
    sys.argv = [&#34;&#34;, &#34;--tunnel&#34;]
    mt_config.args = sys.argv
    print(f&#34;platform.system():{platform.system()}&#34;)
    with caplog.at_level(logging.DEBUG):
        with pytest.raises(SystemExit) as pytest_wrapped_e:
            tunnelMain()
        mock_platform_system.assert_called()
        assert pytest_wrapped_e.type == SystemExit
        assert pytest_wrapped_e.value.code == 1
        out, err = capsys.readouterr()
        assert re.search(r&#34;No.*Meshtastic.*device.*detected&#34;, out, re.MULTILINE)
        assert err == &#34;&#34;</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="meshtastic.tests" href="index.html">meshtastic.tests</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="meshtastic.tests.test_main.test_main_ch_add_but_name_already_exists" href="#meshtastic.tests.test_main.test_main_ch_add_but_name_already_exists">test_main_ch_add_but_name_already_exists</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_ch_add_but_no_more_channels" href="#meshtastic.tests.test_main.test_main_ch_add_but_no_more_channels">test_main_ch_add_but_no_more_channels</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_ch_add_invalid_name_too_long" href="#meshtastic.tests.test_main.test_main_ch_add_invalid_name_too_long">test_main_ch_add_invalid_name_too_long</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_ch_add_valid" href="#meshtastic.tests.test_main.test_main_ch_add_valid">test_main_ch_add_valid</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_ch_del" href="#meshtastic.tests.test_main.test_main_ch_del">test_main_ch_del</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_ch_del_no_ch_index_specified" href="#meshtastic.tests.test_main.test_main_ch_del_no_ch_index_specified">test_main_ch_del_no_ch_index_specified</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_ch_del_primary_channel" href="#meshtastic.tests.test_main.test_main_ch_del_primary_channel">test_main_ch_del_primary_channel</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_ch_disable_valid_secondary_channel" href="#meshtastic.tests.test_main.test_main_ch_disable_valid_secondary_channel">test_main_ch_disable_valid_secondary_channel</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_ch_enable_primary_channel" href="#meshtastic.tests.test_main.test_main_ch_enable_primary_channel">test_main_ch_enable_primary_channel</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_ch_enable_valid_secondary_channel" href="#meshtastic.tests.test_main.test_main_ch_enable_valid_secondary_channel">test_main_ch_enable_valid_secondary_channel</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_ch_enable_without_a_ch_index" href="#meshtastic.tests.test_main.test_main_ch_enable_without_a_ch_index">test_main_ch_enable_without_a_ch_index</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_ch_index_no_devices" href="#meshtastic.tests.test_main.test_main_ch_index_no_devices">test_main_ch_index_no_devices</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_ch_longfast_on_non_primary_channel" href="#meshtastic.tests.test_main.test_main_ch_longfast_on_non_primary_channel">test_main_ch_longfast_on_non_primary_channel</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_ch_set_psk_no_ch_index" href="#meshtastic.tests.test_main.test_main_ch_set_psk_no_ch_index">test_main_ch_set_psk_no_ch_index</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_ch_set_psk_with_ch_index" href="#meshtastic.tests.test_main.test_main_ch_set_psk_with_ch_index">test_main_ch_set_psk_with_ch_index</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_configure_with_camel_case_keys" href="#meshtastic.tests.test_main.test_main_configure_with_camel_case_keys">test_main_configure_with_camel_case_keys</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_configure_with_snake_case" href="#meshtastic.tests.test_main.test_main_configure_with_snake_case">test_main_configure_with_snake_case</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_export_config" href="#meshtastic.tests.test_main.test_main_export_config">test_main_export_config</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_get_canned_messages" href="#meshtastic.tests.test_main.test_main_get_canned_messages">test_main_get_canned_messages</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_get_with_invalid" href="#meshtastic.tests.test_main.test_main_get_with_invalid">test_main_get_with_invalid</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_gpio_rd_no_dest" href="#meshtastic.tests.test_main.test_main_gpio_rd_no_dest">test_main_gpio_rd_no_dest</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_gpio_rd_no_gpio_channel" href="#meshtastic.tests.test_main.test_main_gpio_rd_no_gpio_channel">test_main_gpio_rd_no_gpio_channel</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_info" href="#meshtastic.tests.test_main.test_main_info">test_main_info</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_info_with_permission_error" href="#meshtastic.tests.test_main.test_main_info_with_permission_error">test_main_info_with_permission_error</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_info_with_seriallog_output_txt" href="#meshtastic.tests.test_main.test_main_info_with_seriallog_output_txt">test_main_info_with_seriallog_output_txt</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_info_with_seriallog_stdout" href="#meshtastic.tests.test_main.test_main_info_with_seriallog_stdout">test_main_info_with_seriallog_stdout</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_info_with_tcp_interface" href="#meshtastic.tests.test_main.test_main_info_with_tcp_interface">test_main_info_with_tcp_interface</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_init_parser_no_args" href="#meshtastic.tests.test_main.test_main_init_parser_no_args">test_main_init_parser_no_args</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_init_parser_version" href="#meshtastic.tests.test_main.test_main_init_parser_version">test_main_init_parser_version</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_main_no_args" href="#meshtastic.tests.test_main.test_main_main_no_args">test_main_main_no_args</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_main_version" href="#meshtastic.tests.test_main.test_main_main_version">test_main_main_version</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_no_proto" href="#meshtastic.tests.test_main.test_main_no_proto">test_main_no_proto</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_nodes" href="#meshtastic.tests.test_main.test_main_nodes">test_main_nodes</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_onConnected_exception" href="#meshtastic.tests.test_main.test_main_onConnected_exception">test_main_onConnected_exception</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_onConnection" href="#meshtastic.tests.test_main.test_main_onConnection">test_main_onConnection</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_onReceive_empty" href="#meshtastic.tests.test_main.test_main_onReceive_empty">test_main_onReceive_empty</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_onReceive_with_sendtext" href="#meshtastic.tests.test_main.test_main_onReceive_with_sendtext">test_main_onReceive_with_sendtext</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_onReceive_with_text" href="#meshtastic.tests.test_main.test_main_onReceive_with_text">test_main_onReceive_with_text</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_qr" href="#meshtastic.tests.test_main.test_main_qr">test_main_qr</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_reboot" href="#meshtastic.tests.test_main.test_main_reboot">test_main_reboot</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_removeposition" href="#meshtastic.tests.test_main.test_main_removeposition">test_main_removeposition</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_removeposition_remote" href="#meshtastic.tests.test_main.test_main_removeposition_remote">test_main_removeposition_remote</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_sendtext" href="#meshtastic.tests.test_main.test_main_sendtext">test_main_sendtext</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_sendtext_with_channel" href="#meshtastic.tests.test_main.test_main_sendtext_with_channel">test_main_sendtext_with_channel</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_sendtext_with_dest" href="#meshtastic.tests.test_main.test_main_sendtext_with_dest">test_main_sendtext_with_dest</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_sendtext_with_invalid_channel" href="#meshtastic.tests.test_main.test_main_sendtext_with_invalid_channel">test_main_sendtext_with_invalid_channel</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_sendtext_with_invalid_channel_nine" href="#meshtastic.tests.test_main.test_main_sendtext_with_invalid_channel_nine">test_main_sendtext_with_invalid_channel_nine</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_set_canned_messages" href="#meshtastic.tests.test_main.test_main_set_canned_messages">test_main_set_canned_messages</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_set_ham_to_KI123" href="#meshtastic.tests.test_main.test_main_set_ham_to_KI123">test_main_set_ham_to_KI123</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_set_invalid_wifi_psk" href="#meshtastic.tests.test_main.test_main_set_invalid_wifi_psk">test_main_set_invalid_wifi_psk</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_set_owner_short_to_bob" href="#meshtastic.tests.test_main.test_main_set_owner_short_to_bob">test_main_set_owner_short_to_bob</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_set_owner_to_bob" href="#meshtastic.tests.test_main.test_main_set_owner_to_bob">test_main_set_owner_to_bob</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_set_valid" href="#meshtastic.tests.test_main.test_main_set_valid">test_main_set_valid</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_set_valid_camel_case" href="#meshtastic.tests.test_main.test_main_set_valid_camel_case">test_main_set_valid_camel_case</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_set_valid_wifi_psk" href="#meshtastic.tests.test_main.test_main_set_valid_wifi_psk">test_main_set_valid_wifi_psk</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_set_with_invalid" href="#meshtastic.tests.test_main.test_main_set_with_invalid">test_main_set_with_invalid</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_setalt" href="#meshtastic.tests.test_main.test_main_setalt">test_main_setalt</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_setlat" href="#meshtastic.tests.test_main.test_main_setlat">test_main_setlat</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_setlat_remote" href="#meshtastic.tests.test_main.test_main_setlat_remote">test_main_setlat_remote</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_setlon" href="#meshtastic.tests.test_main.test_main_setlon">test_main_setlon</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_seturl" href="#meshtastic.tests.test_main.test_main_seturl">test_main_seturl</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_shutdown" href="#meshtastic.tests.test_main.test_main_shutdown">test_main_shutdown</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_support" href="#meshtastic.tests.test_main.test_main_support">test_main_support</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_test_no_ports" href="#meshtastic.tests.test_main.test_main_test_no_ports">test_main_test_no_ports</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_test_one_port" href="#meshtastic.tests.test_main.test_main_test_one_port">test_main_test_one_port</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_test_two_ports_fails" href="#meshtastic.tests.test_main.test_main_test_two_ports_fails">test_main_test_two_ports_fails</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_main_test_two_ports_success" href="#meshtastic.tests.test_main.test_main_test_two_ports_success">test_main_test_two_ports_success</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_onNode" href="#meshtastic.tests.test_main.test_onNode">test_onNode</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_tunnel_no_args" href="#meshtastic.tests.test_main.test_tunnel_no_args">test_tunnel_no_args</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_tunnel_subnet_arg_with_no_devices" href="#meshtastic.tests.test_main.test_tunnel_subnet_arg_with_no_devices">test_tunnel_subnet_arg_with_no_devices</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_tunnel_tunnel_arg" href="#meshtastic.tests.test_main.test_tunnel_tunnel_arg">test_tunnel_tunnel_arg</a></code></li>
<li><code><a title="meshtastic.tests.test_main.test_tunnel_tunnel_arg_with_no_devices" href="#meshtastic.tests.test_main.test_tunnel_tunnel_arg_with_no_devices">test_tunnel_tunnel_arg_with_no_devices</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>